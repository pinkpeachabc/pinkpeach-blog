{"title":"Vue3快速上手","date":"2022-02-22T23:51:31.000Z","date_formatted":{"ll":"2022年2月23日","L":"2022/02/23","MM-DD":"02-23"},"author":"粉色桃子abc","thumbnail":"https://s2.loli.net/2022/02/21/Ziu2f9FQ34dLoIE.png","link":"vue3","comments":true,"tags":["vue"],"categories":["笔记"],"updated":"2022-02-23T09:26:33.881Z","content":"<a id=\"more\"></a>\n<h1 id=\"vue3快速上手\">Vue3快速上手<a title=\"#vue3快速上手\" href=\"#vue3快速上手\"></a></h1>\n<p><img src=\"https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png\" alt=\"\" class=\"φbs\"></p>\n<h2 id=\"1.vue3简介\">1.Vue3简介<a title=\"#1.vue3简介\" href=\"#1.vue3简介\"></a></h2>\n<ul>\n<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>\n<li>耗时2年多、<a href=\"https://github.com/vuejs/vue-next/graphs/commit-activity\" target=\"_blank\">2600+次提交</a>、<a href=\"https://github.com/vuejs/rfcs/tree/master/active-rfcs\" target=\"_blank\">30+个RFC</a>、<a href=\"https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+\" target=\"_blank\">600+次PR</a>、<a href=\"https://github.com/vuejs/vue-next/graphs/contributors\" target=\"_blank\">99位贡献者</a></li>\n<li>github上的tags地址：<a href=\"https://github.com/vuejs/vue-next/releases/tag/v3.0.0\">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>\n</ul>\n<h2 id=\"2.vue3带来了什么\">2.Vue3带来了什么<a title=\"#2.vue3带来了什么\" href=\"#2.vue3带来了什么\"></a></h2>\n<h3 id=\"1.性能的提升\">1.性能的提升<a title=\"#1.性能的提升\" href=\"#1.性能的提升\"></a></h3>\n<ul>\n<li>\n<p>打包大小减少41%</p>\n</li>\n<li>\n<p>初次渲染快55%, 更新渲染快133%</p>\n</li>\n<li>\n<p>内存减少54%</p>\n<p>…</p>\n</li>\n</ul>\n<h3 id=\"2.源码的升级\">2.源码的升级<a title=\"#2.源码的升级\" href=\"#2.源码的升级\"></a></h3>\n<ul>\n<li>\n<p>使用Proxy代替defineProperty实现响应式</p>\n</li>\n<li>\n<p>重写虚拟DOM的实现和Tree-Shaking</p>\n<p>…</p>\n</li>\n</ul>\n<h3 id=\"3.拥抱typescript\">3.拥抱TypeScript<a title=\"#3.拥抱typescript\" href=\"#3.拥抱typescript\"></a></h3>\n<ul>\n<li>Vue3可以更好的支持TypeScript</li>\n</ul>\n<h3 id=\"4.新的特性\">4.新的特性<a title=\"#4.新的特性\" href=\"#4.新的特性\"></a></h3>\n<ol>\n<li>\n<p>Composition API（组合API）</p>\n<ul>\n<li>setup配置</li>\n<li>ref与reactive</li>\n<li>watch与watchEffect</li>\n<li>provide与inject</li>\n<li>…</li>\n</ul>\n</li>\n<li>\n<p>新的内置组件</p>\n<ul>\n<li>Fragment</li>\n<li>Teleport</li>\n<li>Suspense</li>\n</ul>\n</li>\n<li>\n<p>其他改变</p>\n<ul>\n<li>新的生命周期钩子</li>\n<li>data 选项应始终被声明为一个函数</li>\n<li>移除keyCode支持作为 v-on 的修饰符</li>\n<li>…</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"一、创建vue3.0工程\">一、创建Vue3.0工程<a title=\"#一、创建vue3.0工程\" href=\"#一、创建vue3.0工程\"></a></h1>\n<h2 id=\"1.使用-vue-cli-创建\">1.使用 vue-cli 创建<a title=\"#1.使用-vue-cli-创建\" href=\"#1.使用-vue-cli-创建\"></a></h2>\n<p>官方文档：<a href=\"https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class=\"line\">vue --version</span><br><span class=\"line\"><span class=\"comment\">## 安装或者升级你的@vue/cli</span></span><br><span class=\"line\">npm install -g @vue/cli</span><br><span class=\"line\"><span class=\"comment\">## 创建</span></span><br><span class=\"line\">vue create vue_test</span><br><span class=\"line\"><span class=\"comment\">## 启动</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> vue_test</span><br><span class=\"line\">npm run serve</span><br></pre></td></tr></table></figure>\n<h2 id=\"2.使用-vite-创建\">2.使用 vite 创建<a title=\"#2.使用-vite-创建\" href=\"#2.使用-vite-创建\"></a></h2>\n<p>官方文档：<a href=\"https://v3.cn.vuejs.org/guide/installation.html#vite\">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>\n<p>vite官网：<a href=\"https://vitejs.cn\">https://vitejs.cn</a></p>\n<ul>\n<li>什么是vite？—— 新一代前端构建工具。</li>\n<li>优势如下：\n<ul>\n<li>开发环境中，无需打包操作，可快速的冷启动。</li>\n<li>轻量快速的热重载（HMR）。</li>\n<li>真正的按需编译，不再等待整个应用编译完成。</li>\n</ul>\n</li>\n<li>传统构建 与 vite构建对比图</li>\n</ul>\n<p><img src=\"https://cn.vitejs.dev/assets/bundler.37740380.png\" alt=\"\" class=\"φbs\"></p>\n<p><img src=\"https://cn.vitejs.dev/assets/esm.3070012d.png\" alt=\"\" class=\"φbs\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 创建工程</span></span><br><span class=\"line\">npm init vite-app &lt;project-name&gt;</span><br><span class=\"line\"><span class=\"comment\">## 进入工程目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> &lt;project-name&gt;</span><br><span class=\"line\"><span class=\"comment\">## 安装依赖</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"><span class=\"comment\">## 运行</span></span><br><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、常用-composition-api\">二、常用 Composition API<a title=\"#二、常用-composition-api\" href=\"#二、常用-composition-api\"></a></h1>\n<p>官方文档: <a href=\"https://v3.cn.vuejs.org/guide/composition-api-introduction.html\">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>\n<h2 id=\"1.拉开序幕的setup\">1.拉开序幕的setup<a title=\"#1.拉开序幕的setup\" href=\"#1.拉开序幕的setup\"></a></h2>\n<ol>\n<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>\n<li>setup是所有<strong style=\"color:#DD5145\">Composition API（组合API）</strong><i style=\"color:gray;font-weight:bold\">“ 表演的舞台 ”</i>。</li>\n<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>\n<li>setup函数的两种返回值：\n<ol>\n<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>\n<li><span style=\"color:#aad\">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>\n</ol>\n</li>\n<li>注意点：\n<ol>\n<li>尽量不要与Vue2.x配置混用\n<ul>\n<li>Vue2.x配置（data、methos、computed…）中<strong style=\"color:#DD5145\">可以访问到</strong>setup中的属性、方法。</li>\n<li>但在setup中<strong style=\"color:#DD5145\">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>\n<li>如果有重名, setup优先。</li>\n</ul>\n</li>\n<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2.ref函数\">2.ref函数<a title=\"#2.ref函数\" href=\"#2.ref函数\"></a></h2>\n<ul>\n<li>作用: 定义一个响应式的数据</li>\n<li>语法: <code>const xxx = ref(initValue)</code>\n<ul>\n<li>创建一个包含响应式数据的<strong style=\"color:#DD5145\">引用对象（reference对象，简称ref对象）</strong>。</li>\n<li>JS中操作数据： <code>xxx.value</code></li>\n<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>\n</ul>\n</li>\n<li>备注：\n<ul>\n<li>接收的数据可以是：基本类型、也可以是对象类型。</li>\n<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>\n<li>对象类型的数据：内部 <i style=\"color:gray;font-weight:bold\">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3.reactive函数\">3.reactive函数<a title=\"#3.reactive函数\" href=\"#3.reactive函数\"></a></h2>\n<ul>\n<li>作用: 定义一个<strong style=\"color:#DD5145\">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>\n<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style=\"color:#DD5145\">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>\n<li>reactive定义的响应式数据是“深层次的”。</li>\n<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>\n</ul>\n<h2 id=\"4.vue3.0中的响应式原理\">4.Vue3.0中的响应式原理<a title=\"#4.vue3.0中的响应式原理\" href=\"#4.vue3.0中的响应式原理\"></a></h2>\n<h3 id=\"vue2.x的响应式\">vue2.x的响应式<a title=\"#vue2.x的响应式\" href=\"#vue2.x的响应式\"></a></h3>\n<ul>\n<li>\n<p>实现原理：</p>\n<ul>\n<li>\n<p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>\n</li>\n<li>\n<p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(data, <span class=\"string\">&#x27;count&#x27;</span>, &#123;</span><br><span class=\"line\">    get () &#123;&#125;, </span><br><span class=\"line\">    set () &#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>存在问题：</p>\n<ul>\n<li>新增属性、删除属性, 界面不会更新。</li>\n<li>直接通过下标修改数组, 界面不会自动更新。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vue3.0的响应式\">Vue3.0的响应式<a title=\"#vue3.0的响应式\" href=\"#vue3.0的响应式\"></a></h3>\n<ul>\n<li>实现原理:\n<ul>\n<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>\n<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>\n<li>MDN文档中描述的Proxy与Reflect：\n<ul>\n<li>\n<p>Proxy：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>\n</li>\n<li>\n<p>Reflect：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(data, &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拦截读取属性值</span></span><br><span class=\"line\">    get (target, prop) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, prop)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 拦截设置属性值或添加新属性</span></span><br><span class=\"line\">    set (target, prop, value) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, prop, value)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 拦截删除属性</span></span><br><span class=\"line\">    deleteProperty (target, prop) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.deleteProperty(target, prop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.name = <span class=\"string\">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5.reactive对比ref\">5.reactive对比ref<a title=\"#5.reactive对比ref\" href=\"#5.reactive对比ref\"></a></h2>\n<ul>\n<li>从定义数据角度对比：\n<ul>\n<li>ref用来定义：<strong style=\"color:#DD5145\">基本类型数据</strong>。</li>\n<li>reactive用来定义：<strong style=\"color:#DD5145\">对象（或数组）类型数据</strong>。</li>\n<li>备注：ref也可以用来定义<strong style=\"color:#DD5145\">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style=\"color:#DD5145\">代理对象</strong>。</li>\n</ul>\n</li>\n<li>从原理角度对比：\n<ul>\n<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>\n<li>reactive通过使用<strong style=\"color:#DD5145\">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style=\"color:#DD5145\">Reflect</strong>操作<strong style=\"color:orange\">源对象</strong>内部的数据。</li>\n</ul>\n</li>\n<li>从使用角度对比：\n<ul>\n<li>ref定义的数据：操作数据<strong style=\"color:#DD5145\">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style=\"color:#DD5145\">不需要</strong><code>.value</code>。</li>\n<li>reactive定义的数据：操作数据与读取数据：<strong style=\"color:#DD5145\">均不需要</strong><code>.value</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6.setup的两个注意点\">6.setup的两个注意点<a title=\"#6.setup的两个注意点\" href=\"#6.setup的两个注意点\"></a></h2>\n<ul>\n<li>\n<p>setup执行的时机</p>\n<ul>\n<li>在beforeCreate之前执行一次，this是undefined。</li>\n</ul>\n</li>\n<li>\n<p>setup的参数</p>\n<ul>\n<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>\n<li>context：上下文对象\n<ul>\n<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>\n<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>\n<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7.计算属性与监视\">7.计算属性与监视<a title=\"#7.计算属性与监视\" href=\"#7.计算属性与监视\"></a></h2>\n<h3 id=\"1.computed函数\">1.computed函数<a title=\"#1.computed函数\" href=\"#1.computed函数\"></a></h3>\n<ul>\n<li>\n<p>与Vue2.x中computed配置功能一致</p>\n</li>\n<li>\n<p>写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;computed&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">//计算属性——简写</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fullName = computed(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> person.firstName + <span class=\"string\">&#x27;-&#x27;</span> + person.lastName</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//计算属性——完整</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fullName = computed(&#123;</span><br><span class=\"line\">        get()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> person.firstName + <span class=\"string\">&#x27;-&#x27;</span> + person.lastName</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set(value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nameArr = value.split(<span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">            person.firstName = nameArr[<span class=\"number\">0</span>]</span><br><span class=\"line\">            person.lastName = nameArr[<span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2.watch函数\">2.watch函数<a title=\"#2.watch函数\" href=\"#2.watch函数\"></a></h3>\n<ul>\n<li>\n<p>与Vue2.x中watch配置功能一致</p>\n</li>\n<li>\n<p>两个小“坑”：</p>\n<ul>\n<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>\n<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//情况一：监视ref定义的响应式数据</span></span><br><span class=\"line\">watch(sum,<span class=\"function\">(<span class=\"params\">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">immediate</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//情况二：监视多个ref定义的响应式数据</span></span><br><span class=\"line\">watch([sum,msg],<span class=\"function\">(<span class=\"params\">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">watch(person,<span class=\"function\">(<span class=\"params\">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">immediate</span>:<span class=\"literal\">true</span>,<span class=\"attr\">deep</span>:<span class=\"literal\">false</span>&#125;) <span class=\"comment\">//此处的deep配置不再奏效</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class=\"line\">watch(<span class=\"function\">()=&gt;</span>person.job,<span class=\"function\">(<span class=\"params\">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">immediate</span>:<span class=\"literal\">true</span>,<span class=\"attr\">deep</span>:<span class=\"literal\">true</span>&#125;) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class=\"line\">watch([<span class=\"function\">()=&gt;</span>person.job,<span class=\"function\">()=&gt;</span>person.name],<span class=\"function\">(<span class=\"params\">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">immediate</span>:<span class=\"literal\">true</span>,<span class=\"attr\">deep</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//特殊情况</span></span><br><span class=\"line\">watch(<span class=\"function\">()=&gt;</span>person.job,<span class=\"function\">(<span class=\"params\">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">deep</span>:<span class=\"literal\">true</span>&#125;) <span class=\"comment\">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3.watcheffect函数\">3.watchEffect函数<a title=\"#3.watcheffect函数\" href=\"#3.watcheffect函数\"></a></h3>\n<ul>\n<li>\n<p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>\n</li>\n<li>\n<p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>\n</li>\n<li>\n<p>watchEffect有点像computed：</p>\n<ul>\n<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>\n<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class=\"line\">watchEffect(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> x1 = sum.value</span><br><span class=\"line\">    <span class=\"keyword\">const</span> x2 = person.age</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"8.生命周期\">8.生命周期<a title=\"#8.生命周期\" href=\"#8.生命周期\"></a></h2>\n<ul>\n<li>vue2.x的生命周期</li>\n</ul>\n<p><img src=\"https://cn.vuejs.org/images/lifecycle.png\" alt=\"\" class=\"φbs\"></p>\n<ul>\n<li>vue3.0的生命周期</li>\n</ul>\n<p><img src=\"https://v3.cn.vuejs.org/images/lifecycle.svg\" alt=\"\" class=\"φbs\"></p>\n<ul>\n<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\n<ul>\n<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>\n<li><code>destroyed</code>改名为 <code>unmounted</code></li>\n</ul>\n</li>\n<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\n<ul>\n<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>\n<li><code>created</code>=======&gt;<code>setup()</code></li>\n<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>\n<li><code>mounted</code>=======&gt;<code>onMounted</code></li>\n<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>\n<li><code>updated</code> =======&gt;<code>onUpdated</code></li>\n<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>\n<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9.自定义hook函数\">9.自定义hook函数<a title=\"#9.自定义hook函数\" href=\"#9.自定义hook函数\"></a></h2>\n<ul>\n<li>\n<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>\n</li>\n<li>\n<p>类似于vue2.x中的mixin。</p>\n</li>\n<li>\n<p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>\n</li>\n</ul>\n<h2 id=\"10.toref\">10.toRef<a title=\"#10.toref\" href=\"#10.toref\"></a></h2>\n<ul>\n<li>\n<p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>\n</li>\n<li>\n<p>语法：<code>const name = toRef(person,'name')</code></p>\n</li>\n<li>\n<p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>\n</li>\n<li>\n<p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>\n</li>\n</ul>\n<h1 id=\"三、其它-composition-api\">三、其它 Composition API<a title=\"#三、其它-composition-api\" href=\"#三、其它-composition-api\"></a></h1>\n<h2 id=\"1.shallowreactive-与-shallowref\">1.shallowReactive 与 shallowRef<a title=\"#1.shallowreactive-与-shallowref\" href=\"#1.shallowreactive-与-shallowref\"></a></h2>\n<ul>\n<li>\n<p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>\n</li>\n<li>\n<p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>\n</li>\n<li>\n<p>什么时候使用?</p>\n<ul>\n<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>\n<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2.readonly-与-shallowreadonly\">2.readonly 与 shallowReadonly<a title=\"#2.readonly-与-shallowreadonly\" href=\"#2.readonly-与-shallowreadonly\"></a></h2>\n<ul>\n<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>\n<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>\n<li>应用场景: 不希望数据被修改时。</li>\n</ul>\n<h2 id=\"3.toraw-与-markraw\">3.toRaw 与 markRaw<a title=\"#3.toraw-与-markraw\" href=\"#3.toraw-与-markraw\"></a></h2>\n<ul>\n<li>toRaw：\n<ul>\n<li>作用：将一个由<code>reactive</code>生成的<strong style=\"color:orange\">响应式对象</strong>转为<strong style=\"color:orange\">普通对象</strong>。</li>\n<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>\n</ul>\n</li>\n<li>markRaw：\n<ul>\n<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>\n<li>应用场景:\n<ol>\n<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>\n<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4.customref\">4.customRef<a title=\"#4.customref\" href=\"#4.customref\"></a></h2>\n<ul>\n<li>\n<p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>\n</li>\n<li>\n<p>实现防抖效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyword&quot;&gt;</span><br><span class=\"line\">\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\timport &#123;ref,customRef&#125; from &#39;vue&#39;</span><br><span class=\"line\">\texport default &#123;</span><br><span class=\"line\">\t\tname:&#39;Demo&#39;,</span><br><span class=\"line\">\t\tsetup()&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; let keyword &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F;使用Vue准备好的内置ref</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;自定义一个myRef</span><br><span class=\"line\">\t\t\tfunction myRef(value,delay)&#123;</span><br><span class=\"line\">\t\t\t\tlet timer</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;通过customRef去实现自定义</span><br><span class=\"line\">\t\t\t\treturn customRef((track,trigger)&#x3D;&gt;&#123;</span><br><span class=\"line\">\t\t\t\t\treturn&#123;</span><br><span class=\"line\">\t\t\t\t\t\tget()&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\ttrack() &#x2F;&#x2F;告诉Vue这个value值是需要被“追踪”的</span><br><span class=\"line\">\t\t\t\t\t\t\treturn value</span><br><span class=\"line\">\t\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t\tset(newValue)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tclearTimeout(timer)</span><br><span class=\"line\">\t\t\t\t\t\t\ttimer &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tvalue &#x3D; newValue</span><br><span class=\"line\">\t\t\t\t\t\t\t\ttrigger() &#x2F;&#x2F;告诉Vue去更新界面</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;,delay)</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlet keyword &#x3D; myRef(&#39;hello&#39;,500) &#x2F;&#x2F;使用程序员自定义的ref</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tkeyword</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"5.provide-与-inject\">5.provide 与 inject<a title=\"#5.provide-与-inject\" href=\"#5.provide-与-inject\"></a></h2>\n<p><img src=\"https://v3.cn.vuejs.org/images/components_provide.png\" alt=\"\" class=\"φbs\"></p>\n<ul>\n<li>\n<p>作用：实现<strong style=\"color:#DD5145\">祖与后代组件间</strong>通信</p>\n</li>\n<li>\n<p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>\n</li>\n<li>\n<p>具体写法：</p>\n<ol>\n<li>\n<p>祖组件中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup()&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">let</span> car = reactive(&#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;奔驰&#x27;</span>,<span class=\"attr\">price</span>:<span class=\"string\">&#x27;40万&#x27;</span>&#125;)</span><br><span class=\"line\">    provide(<span class=\"string\">&#x27;car&#x27;</span>,car)</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>后代组件中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup(props,context)&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">const</span> car = inject(<span class=\"string\">&#x27;car&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;car&#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"6.响应式数据的判断\">6.响应式数据的判断<a title=\"#6.响应式数据的判断\" href=\"#6.响应式数据的判断\"></a></h2>\n<ul>\n<li>isRef: 检查一个值是否为一个 ref 对象</li>\n<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>\n<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>\n<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>\n</ul>\n<h1 id=\"四、composition-api-的优势\">四、Composition API 的优势<a title=\"#四、composition-api-的优势\" href=\"#四、composition-api-的优势\"></a></h1>\n<h2 id=\"1.options-api-存在的问题\">1.Options API 存在的问题<a title=\"#1.options-api-存在的问题\" href=\"#1.options-api-存在的问题\"></a></h2>\n<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" class=\"φbs\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" class=\"φbs\"></p>\n<h2 id=\"2.composition-api-的优势\">2.Composition API 的优势<a title=\"#2.composition-api-的优势\" href=\"#2.composition-api-的优势\"></a></h2>\n<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" class=\"φbs\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" class=\"φbs\"></p>\n<h1 id=\"五、新的组件\">五、新的组件<a title=\"#五、新的组件\" href=\"#五、新的组件\"></a></h1>\n<h2 id=\"1.fragment\">1.Fragment<a title=\"#1.fragment\" href=\"#1.fragment\"></a></h2>\n<ul>\n<li>在Vue2中: 组件必须有一个根标签</li>\n<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>\n<li>好处: 减少标签层级, 减小内存占用</li>\n</ul>\n<h2 id=\"2.teleport\">2.Teleport<a title=\"#2.teleport\" href=\"#2.teleport\"></a></h2>\n<ul>\n<li>\n<p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style=\"color:#DD5145\">组件html结构</strong>移动到指定位置的技术。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;teleport to&#x3D;&quot;移动位置&quot;&gt;</span><br><span class=\"line\">\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;</span><br><span class=\"line\">\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;</span><br><span class=\"line\">\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;teleport&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"3.suspense\">3.Suspense<a title=\"#3.suspense\" href=\"#3.suspense\"></a></h2>\n<ul>\n<li>\n<p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>\n</li>\n<li>\n<p>使用步骤：</p>\n<ul>\n<li>\n<p>异步引入组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;defineAsyncComponent&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Child = defineAsyncComponent(<span class=\"function\">()=&gt;</span><span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;</span><br><span class=\"line\">\t\t&lt;Suspense&gt;</span><br><span class=\"line\">\t\t\t&lt;template v-slot:default&gt;</span><br><span class=\"line\">\t\t\t\t&lt;Child&#x2F;&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;template&gt;</span><br><span class=\"line\">\t\t\t&lt;template v-slot:fallback&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;template&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;Suspense&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"六、其他\">六、其他<a title=\"#六、其他\" href=\"#六、其他\"></a></h1>\n<h2 id=\"1.全局api的转移\">1.全局API的转移<a title=\"#1.全局api的转移\" href=\"#1.全局api的转移\"></a></h2>\n<ul>\n<li>\n<p>Vue 2.x 有许多全局 API 和配置。</p>\n<ul>\n<li>\n<p>例如：注册全局组件、注册全局指令等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册全局组件</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class=\"line\">  data: <span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  template: <span class=\"string\">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册全局指令</span></span><br><span class=\"line\">Vue.directive(<span class=\"string\">&#x27;focus&#x27;</span>, &#123;</span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.focus()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>Vue3.0中对这些API做出了调整：</p>\n<ul>\n<li>\n<p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th>2.x 全局 API（<code>Vue</code>）</th>\n<th>3.x 实例 API (<code>app</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Vue.config.xxxx</td>\n<td>app.config.xxxx</td>\n</tr>\n<tr>\n<td>Vue.config.productionTip</td>\n<td><strong style=\"color:#DD5145\">移除</strong></td>\n</tr>\n<tr>\n<td>Vue.component</td>\n<td>app.component</td>\n</tr>\n<tr>\n<td>Vue.directive</td>\n<td>app.directive</td>\n</tr>\n<tr>\n<td>Vue.mixin</td>\n<td>app.mixin</td>\n</tr>\n<tr>\n<td>Vue.use</td>\n<td>app.use</td>\n</tr>\n<tr>\n<td>Vue.prototype</td>\n<td>app.config.globalProperties</td>\n</tr>\n</tbody>\n</table></div></div></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2.其他改变\">2.其他改变<a title=\"#2.其他改变\" href=\"#2.其他改变\"></a></h2>\n<ul>\n<li>\n<p>data选项应始终被声明为一个函数。</p>\n</li>\n<li>\n<p>过度类名的更改：</p>\n<ul>\n<li>\n<p>Vue2.x写法</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v-enter</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.v-leave-to</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.v-leave</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.v-enter-to</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Vue3.x写法</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v-enter-from</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.v-leave-to</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v-leave-from</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.v-enter-to</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><strong style=\"color:#DD5145\">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>\n</li>\n<li>\n<p><strong style=\"color:#DD5145\">移除</strong><code>v-on.native</code>修饰符</p>\n<ul>\n<li>\n<p>父组件中绑定事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component</span><br><span class=\"line\">  v-on:close&#x3D;&quot;handleComponentEvent&quot;</span><br><span class=\"line\">  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>子组件中声明自定义事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">    emits: [&#39;close&#39;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><strong style=\"color:#DD5145\">移除</strong>过滤器（filter）</p>\n<blockquote>\n<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>\n</blockquote>\n</li>\n<li>\n<p>…</p>\n</li>\n</ul>\n","prev":{"title":"免费VPS推荐：Evolution Host","link":"2022-06-14-免费VPS推荐：Evolution-Host"},"next":{"title":"Vue张天禹老师笔记","link":"vue2"},"plink":"https://pinkpeachabc.cn/vue3/","toc":[{"id":"vue3快速上手","title":"Vue3快速上手","index":"1","children":[{"id":"1.vue3简介","title":"1.Vue3简介","index":"1.1"},{"id":"2.vue3带来了什么","title":"2.Vue3带来了什么","index":"1.2","children":[{"id":"1.性能的提升","title":"1.性能的提升","index":"1.2.1"},{"id":"2.源码的升级","title":"2.源码的升级","index":"1.2.2"},{"id":"3.拥抱typescript","title":"3.拥抱TypeScript","index":"1.2.3"},{"id":"4.新的特性","title":"4.新的特性","index":"1.2.4"}]}]},{"id":"一、创建vue3.0工程","title":"一、创建Vue3.0工程","index":"2","children":[{"id":"1.使用-vue-cli-创建","title":"1.使用 vue-cli 创建","index":"2.1"},{"id":"2.使用-vite-创建","title":"2.使用 vite 创建","index":"2.2"}]},{"id":"二、常用-composition-api","title":"二、常用 Composition API","index":"3","children":[{"id":"1.拉开序幕的setup","title":"1.拉开序幕的setup","index":"3.1"},{"id":"2.ref函数","title":"2.ref函数","index":"3.2"},{"id":"3.reactive函数","title":"3.reactive函数","index":"3.3"},{"id":"4.vue3.0中的响应式原理","title":"4.Vue3.0中的响应式原理","index":"3.4","children":[{"id":"vue2.x的响应式","title":"vue2.x的响应式","index":"3.4.1"},{"id":"vue3.0的响应式","title":"Vue3.0的响应式","index":"3.4.2"}]},{"id":"5.reactive对比ref","title":"5.reactive对比ref","index":"3.5"},{"id":"6.setup的两个注意点","title":"6.setup的两个注意点","index":"3.6"},{"id":"7.计算属性与监视","title":"7.计算属性与监视","index":"3.7","children":[{"id":"1.computed函数","title":"1.computed函数","index":"3.7.1"},{"id":"2.watch函数","title":"2.watch函数","index":"3.7.2"},{"id":"3.watcheffect函数","title":"3.watchEffect函数","index":"3.7.3"}]},{"id":"8.生命周期","title":"8.生命周期","index":"3.8"},{"id":"9.自定义hook函数","title":"9.自定义hook函数","index":"3.9"},{"id":"10.toref","title":"10.toRef","index":"3.10"}]},{"id":"三、其它-composition-api","title":"三、其它 Composition API","index":"4","children":[{"id":"1.shallowreactive-与-shallowref","title":"1.shallowReactive 与 shallowRef","index":"4.1"},{"id":"2.readonly-与-shallowreadonly","title":"2.readonly 与 shallowReadonly","index":"4.2"},{"id":"3.toraw-与-markraw","title":"3.toRaw 与 markRaw","index":"4.3"},{"id":"4.customref","title":"4.customRef","index":"4.4"},{"id":"5.provide-与-inject","title":"5.provide 与 inject","index":"4.5"},{"id":"6.响应式数据的判断","title":"6.响应式数据的判断","index":"4.6"}]},{"id":"四、composition-api-的优势","title":"四、Composition API 的优势","index":"5","children":[{"id":"1.options-api-存在的问题","title":"1.Options API 存在的问题","index":"5.1"},{"id":"2.composition-api-的优势","title":"2.Composition API 的优势","index":"5.2"}]},{"id":"五、新的组件","title":"五、新的组件","index":"6","children":[{"id":"1.fragment","title":"1.Fragment","index":"6.1"},{"id":"2.teleport","title":"2.Teleport","index":"6.2"},{"id":"3.suspense","title":"3.Suspense","index":"6.3"}]},{"id":"六、其他","title":"六、其他","index":"7","children":[{"id":"1.全局api的转移","title":"1.全局API的转移","index":"7.1"},{"id":"2.其他改变","title":"2.其他改变","index":"7.2"}]}],"reward":true,"copyright":{"license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","link":"<a href=\"https://pinkpeachabc.cn/vue3/\" title=\"Vue3快速上手\">https://pinkpeachabc.cn/vue3/</a>"},"reading_time":"3988 words in 27 min"}