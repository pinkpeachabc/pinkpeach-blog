[{"title":"Blog定位方向和主题选择","date":"2020-02-08T07:40:13.000Z","date_formatted":{"ll":"2020年2月8日","L":"2020/02/08","MM-DD":"02-08"},"updated":"2022-06-14T05:16:13.500Z","content":"关于Blog\n\n本站历史\n\n博客从2019.8.11至今已经运行由于磕磕绊绊只能从19年开始计算😁\n\n2018.8月建立，使用开源博客程序Jekyll，托管于GIthub pages，域名为pinkpeachabc.githu.io\n2018.12月，更换为开源博客程序hexo，托管于GIthub pages\n2019.3月，由于访问速度原因，将博客迁移阿里云，域名为pinkpeachabc.cn\n2020.2月，主题由Archer换为Typography\n2020.5月，很可惜Typography对排版的支持很差，不得已抛弃，主题换为inside.\n\n起步\n\n📝记录从初识到熟悉的过程\n\n第一次搭建blog的准确时间是2018年的8月份，出于分享和写作。我初建是Github pages + Jekyll的组合方式。\n\n博客版本管理\n静态博客网站\n不需要像WordPress那样繁琐(其实是比较懒)\n可以直接在github网页版上编辑和发布博客\n\n总之是把博客搭建好了，可之后的过程我变没在管过。由于各式各样的原因(就是玩去了)也不写文章，于是我的第一个博客也就经过长时间的吃土💸，直至我最终把它抛弃。\n再次起步\n\n由于上一次的失败，我便很久没有再次搭建博客的想法了。但是我本人喜欢看科技文章，看的久了也想自己写点把自己知道的分享给其他人。由于刚好那时候在学习前端的东西。于是我想不如在搭建一个吧。那时候想想其实写文章发布到网上的平台很多，没必要单独自己搭建一个。\n\n博客园\nCSDN\n简书\n知乎\n\n还有很多很多就不多赘述了，其实真正再次搭建是觉得自己操作可以学习Git和其他方面的只是于是就开始二次起步。\n这一次使用的和第二次不同这次是Github + hexo的组合，搭建起来也是比较轻松。直接放到了github上面取名Pinkpeachabc.github.io并选择了Archer作为博客的主题。\n出于Github的服务器在国外，国内的访问速度很缓慢（龟速）。于是我在阿里云购买了服务器，并且购买第一个域名pinkpeachabc.cn我也没辜负之死去的博客，从建站至今我还在更新着博客，虽然目前没什么技术含量。起码不会再让它吃土了😁\n至今\n可以看到现在的主题已经更换为 Typography当然了我并不是喜新厌旧🌶，经过这几个月的运营博客来看，我太注重外观反而缺少了对阅读和观感体验（注重图片添加无用插件等等）。同样的我也开始想起建博客的初衷。这个是主题是我无意间看到了给我简洁而不失美观的感觉。想初衷的作者一样——重新发现 文字之美\n很可惜Typography对于排版不是很友好，并且不支持目录，我目前的能力没有办法完善，只能对它说抱歉了。由于疫情的原因，学校🏫也暂未开学。这期间我对博客以后的方向思考了很多，我将会把学习中的笔记整理发布在博客中(尽最大可能写优质)，我也会删除一些我自认为无用的文章，让整个博客看起来更高效优质——2020-5-20\n致谢\n对于以上的所有作者我由衷的表示感谢，开源分享、技术无价。同时本次应用的并不是原版的Typography本是基于journey.ad修改过的版本。由于这次的主题layout里面是jade写的所以修改起来可能有点难度，所以我直接抄借鉴了过来。\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A22.png","plink":"https://pinkpeachabc.cn/theme-change/"},{"title":"天软助手","date":"2022-07-06T08:07:57.000Z","date_formatted":{"ll":"2022年7月6日","L":"2022/07/06","MM-DD":"07-06"},"author":"粉色桃子abc","updated":"2022-07-06T16:12:27.116Z","content":"\nHello 大家好我是 @粉色桃子abc，今天跟开心给大家带来一个全新的签到系统-天软助手\n免责声明：为避免纠纷，特做出如下说明：@粉色桃子abc为此系统的真正所有者，今后由天软助手使用导致的一切的后果，其责任概由使用者自己承担，与本人无关，特此声明！\n\n\n登录\n焕然一新\n\n对比前系统改头换面\n如果有会CSS的请速联系我样式太难了🤣\n\n\n首页\n全新监控\n\n学期实践分\n归宿状态\nEcharts 图表-每日得分-每月工资\n\n\n晚签\n世界各地\n\n支持全国空降(仅限中国)\n小熊猫的位置是签到的地点\n\n\n晨跑&amp;升旗\n平平无奇\n\n无聊的功能没有什么可说的\n\n\n\n校讯通\n便捷通知\n\n支持pc端直接下载文档（手机端老iPhone连文档都下载不了吔屎啦）\n\n\n\n健康档案\n一键提交\n\n饱受诟病的健康打卡如今您只需要输入地址点击提交即可\n\n\n活动大咖\n宕机小子\n\n支持pc抢活动和定位签到功能（待开发）\n帮你解决手机卡死还抢不到活动的难题\n\n\n黑暗模式\n一键切换\n\n支持黑暗模式（小米手机开启黑暗模式会反转手机色彩导致网站颜色失调）\n\n\nFind Me\n天软助手：tjise.pinkpeachabc.cn\n我的博客：pinkpeachabc.cn\n我的邮箱：pinkpeachabc@163.com\n广告\n\n好朋友（网安大佬）做了一个公众号，上面不定期分享安全文章感兴趣的小伙伴可以关注一下。\n\n\n\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A29.png","plink":"https://pinkpeachabc.cn/天软助手/"},{"title":"免费VPS推荐：Evolution Host","date":"2022-06-13T19:18:25.000Z","date_formatted":{"ll":"2022年6月14日","L":"2022/06/14","MM-DD":"06-14"},"author":"粉色桃子abc","updated":"2022-07-06T16:15:25.565Z","content":"\n今天推荐一款号称永久免费的VPS主机：Evolution Host：https://evolution-host.com/vps-hosting.php\n\n\n免费VPS推荐：Evolution Host\n\nEvolution Host 是一家自2012年以来一直存在，并且自2013年以来一直在托管解决方案方面进行交易（以前称为evolutionhost.co.uk）。我们希望每6个月左右为品牌引入新技术，新位置和/或新服务，从而保持与时俱进的吸引力。 我们提供100％专用的KVM资源，具有稳定的CPU时间可用性和高时钟速度。阅读：不进行节流或标记化。我们的VPS特别适合游戏服务器托管，其CPU核心时钟高达5.0Ghz，从而实现了很高的单核性能。高时钟速度对于更传统的工作负载也有好处。\n\n免费VPS\n免费VPS配置：\n\n4Ghz +上的4个CPU内核\n4GB DDR4内存\n80GB SSD或350GB HDD\n1Gb / s端口\n60TB每月传输\n先进的DDoS防护\nLinux或Windows\n欧洲/美国位置\n\n免费申请\n申请地址： →→传送门\nWe do not accept applications for websites of a pornographic nature. Site popularity and relevancy will be the biggest deciding factor for each applicant.\nDon’t worry if you feel your website won’t be eligible for the spec mentioned above, we may be able to offer you an alternate free VPS package.\n\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/20220614131456.jpg","plink":"https://pinkpeachabc.cn/2022-06-14-免费VPS推荐：Evolution-Host/"},{"title":"Vue3快速上手","date":"2022-02-22T23:51:31.000Z","date_formatted":{"ll":"2022年2月23日","L":"2022/02/23","MM-DD":"02-23"},"author":"粉色桃子abc","updated":"2022-02-23T09:26:33.881Z","content":"\nVue3快速上手\n\n1.Vue3简介\n\n2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）\n耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者\ngithub上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n2.Vue3带来了什么\n1.性能的提升\n\n\n打包大小减少41%\n\n\n初次渲染快55%, 更新渲染快133%\n\n\n内存减少54%\n…\n\n\n2.源码的升级\n\n\n使用Proxy代替defineProperty实现响应式\n\n\n重写虚拟DOM的实现和Tree-Shaking\n…\n\n\n3.拥抱TypeScript\n\nVue3可以更好的支持TypeScript\n\n4.新的特性\n\n\nComposition API（组合API）\n\nsetup配置\nref与reactive\nwatch与watchEffect\nprovide与inject\n…\n\n\n\n新的内置组件\n\nFragment\nTeleport\nSuspense\n\n\n\n其他改变\n\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n…\n\n\n\n一、创建Vue3.0工程\n1.使用 vue-cli 创建\n官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n123456789## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve\n2.使用 vite 创建\n官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\nvite官网：https://vitejs.cn\n\n什么是vite？—— 新一代前端构建工具。\n优势如下：\n\n开发环境中，无需打包操作，可快速的冷启动。\n轻量快速的热重载（HMR）。\n真正的按需编译，不再等待整个应用编译完成。\n\n\n传统构建 与 vite构建对比图\n\n\n\n12345678## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev\n二、常用 Composition API\n官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html\n1.拉开序幕的setup\n\n理解：Vue3.0中一个新的配置项，值为一个函数。\nsetup是所有Composition API（组合API）“ 表演的舞台 ”。\n组件中所用到的：数据、方法等等，均要配置在setup中。\nsetup函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n\n注意点：\n\n尽量不要与Vue2.x配置混用\n\nVue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。\n但在setup中不能访问到Vue2.x配置（data、methos、computed…）。\n如果有重名, setup优先。\n\n\nsetup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n\n\n2.ref函数\n\n作用: 定义一个响应式的数据\n语法: const xxx = ref(initValue)\n\n创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。\nJS中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;\n\n\n备注：\n\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。\n\n\n\n3.reactive函数\n\n作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）\nreactive定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n4.Vue3.0中的响应式原理\nvue2.x的响应式\n\n\n实现原理：\n\n\n对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n\n\n数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n1234Object.defineProperty(data, &#x27;count&#x27;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)\n\n\n\n\n存在问题：\n\n新增属性、删除属性, 界面不会更新。\n直接通过下标修改数组, 界面不会自动更新。\n\n\n\nVue3.0的响应式\n\n实现原理:\n\n通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n通过Reflect（反射）:  对源对象的属性进行操作。\nMDN文档中描述的Proxy与Reflect：\n\n\nProxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n\n\nReflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\n12345678910111213141516new Proxy(data, &#123;\t// 拦截读取属性值    get (target, prop) &#123;    \treturn Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;    \treturn Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;    \treturn Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#x27;tom&#x27;   \n\n\n\n\n\n\n5.reactive对比ref\n\n从定义数据角度对比：\n\nref用来定义：基本类型数据。\nreactive用来定义：对象（或数组）类型数据。\n备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n\n\n从原理角度对比：\n\nref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\nreactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n\n\n从使用角度对比：\n\nref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\nreactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n\n6.setup的两个注意点\n\n\nsetup执行的时机\n\n在beforeCreate之前执行一次，this是undefined。\n\n\n\nsetup的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\n\nattrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\n\n\n7.计算属性与监视\n1.computed函数\n\n\n与Vue2.x中computed配置功能一致\n\n\n写法\n1234567891011121314151617181920import &#123;computed&#125; from &#x27;vue&#x27;setup()&#123;    ...\t//计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#x27;-&#x27; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#x27;-&#x27; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#x27;-&#x27;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;\n\n\n2.watch函数\n\n\n与Vue2.x中watch配置功能一致\n\n\n两个小“坑”：\n\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n1234567891011121314151617181920212223242526272829303132//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\n\n3.watchEffect函数\n\n\nwatch的套路是：既要指明监视的属性，也要指明监视的回调。\n\n\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\n\nwatchEffect有点像computed：\n\n但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n123456//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;)\n\n\n8.生命周期\n\nvue2.x的生命周期\n\n\n\nvue3.0的生命周期\n\n\n\nVue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\n\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\n\n\nVue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\n\nbeforeCreate===&gt;setup()\ncreated=======&gt;setup()\nbeforeMount ===&gt;onBeforeMount\nmounted=======&gt;onMounted\nbeforeUpdate===&gt;onBeforeUpdate\nupdated =======&gt;onUpdated\nbeforeUnmount ==&gt;onBeforeUnmount\nunmounted =====&gt;onUnmounted\n\n\n\n9.自定义hook函数\n\n\n什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。\n\n\n类似于vue2.x中的mixin。\n\n\n自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\n\n10.toRef\n\n\n作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。\n\n\n语法：const name = toRef(person,'name')\n\n\n应用:   要将响应式对象中的某个属性单独提供给外部使用时。\n\n\n扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\n\n三、其它 Composition API\n1.shallowReactive 与 shallowRef\n\n\nshallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n\n\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n\n什么时候使用?\n\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。\n\n\n\n2.readonly 与 shallowReadonly\n\nreadonly: 让一个响应式数据变为只读的（深只读）。\nshallowReadonly：让一个响应式数据变为只读的（浅只读）。\n应用场景: 不希望数据被修改时。\n\n3.toRaw 与 markRaw\n\ntoRaw：\n\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n\n\nmarkRaw：\n\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n\n\n\n4.customRef\n\n\n作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n\n\n实现防抖效果：\n1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt;\t&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyword&quot;&gt;\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;&#x2F;h3&gt;&lt;&#x2F;template&gt;&lt;script&gt;\timport &#123;ref,customRef&#125; from &#39;vue&#39;\texport default &#123;\t\tname:&#39;Demo&#39;,\t\tsetup()&#123;\t\t\t&#x2F;&#x2F; let keyword &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F;使用Vue准备好的内置ref\t\t\t&#x2F;&#x2F;自定义一个myRef\t\t\tfunction myRef(value,delay)&#123;\t\t\t\tlet timer\t\t\t\t&#x2F;&#x2F;通过customRef去实现自定义\t\t\t\treturn customRef((track,trigger)&#x3D;&gt;&#123;\t\t\t\t\treturn&#123;\t\t\t\t\t\tget()&#123;\t\t\t\t\t\t\ttrack() &#x2F;&#x2F;告诉Vue这个value值是需要被“追踪”的\t\t\t\t\t\t\treturn value\t\t\t\t\t\t&#125;,\t\t\t\t\t\tset(newValue)&#123;\t\t\t\t\t\t\tclearTimeout(timer)\t\t\t\t\t\t\ttimer &#x3D; setTimeout(()&#x3D;&gt;&#123;\t\t\t\t\t\t\t\tvalue &#x3D; newValue\t\t\t\t\t\t\t\ttrigger() &#x2F;&#x2F;告诉Vue去更新界面\t\t\t\t\t\t\t&#125;,delay)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t\tlet keyword &#x3D; myRef(&#39;hello&#39;,500) &#x2F;&#x2F;使用程序员自定义的ref\t\t\treturn &#123;\t\t\t\tkeyword\t\t\t&#125;\t\t&#125;\t&#125;&lt;&#x2F;script&gt;\n\n\n5.provide 与 inject\n\n\n\n作用：实现祖与后代组件间通信\n\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n\n具体写法：\n\n\n祖组件中：\n123456setup()&#123;\t......    let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;)    provide(&#x27;car&#x27;,car)    ......&#125;\n\n\n后代组件中：\n123456setup(props,context)&#123;\t......    const car = inject(&#x27;car&#x27;)    return &#123;car&#125;\t......&#125;\n\n\n\n\n6.响应式数据的判断\n\nisRef: 检查一个值是否为一个 ref 对象\nisReactive: 检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly: 检查一个对象是否是由 readonly 创建的只读代理\nisProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n四、Composition API 的优势\n1.Options API 存在的问题\n使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。\n\n\n2.Composition API 的优势\n我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n\n五、新的组件\n1.Fragment\n\n在Vue2中: 组件必须有一个根标签\n在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\n2.Teleport\n\n\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。\n12345678&lt;teleport to&#x3D;&quot;移动位置&quot;&gt;\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\t\t&lt;&#x2F;div&gt;\t&lt;&#x2F;div&gt;&lt;&#x2F;teleport&gt;\n\n\n3.Suspense\n\n\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n\n使用步骤：\n\n\n异步引入组件\n12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;))\n\n\n使用Suspense包裹组件，并配置好default 与 fallback\n12345678910111213&lt;template&gt;\t&lt;div class&#x3D;&quot;app&quot;&gt;\t\t&lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\t\t&lt;Suspense&gt;\t\t\t&lt;template v-slot:default&gt;\t\t\t\t&lt;Child&#x2F;&gt;\t\t\t&lt;&#x2F;template&gt;\t\t\t&lt;template v-slot:fallback&gt;\t\t\t\t&lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\t\t\t&lt;&#x2F;template&gt;\t\t&lt;&#x2F;Suspense&gt;\t&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;\n\n\n\n\n六、其他\n1.全局API的转移\n\n\nVue 2.x 有许多全局 API 和配置。\n\n\n例如：注册全局组件、注册全局指令等。\n123456789101112//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123;  inserted: el =&gt; el.focus()&#125;\n\n\n\n\nVue3.0中对这些API做出了调整：\n\n\n将全局的API，即：Vue.xxx调整到应用实例（app）上\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n\n\n\n\n2.其他改变\n\n\ndata选项应始终被声明为一个函数。\n\n\n过度类名的更改：\n\n\nVue2.x写法\n12345678.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;\n\n\nVue3.x写法\n123456789.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;\n\n\n\n\n移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes\n\n\n移除v-on.native修饰符\n\n\n父组件中绑定事件\n1234&lt;my-component  v-on:close&#x3D;&quot;handleComponentEvent&quot;  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;&#x2F;&gt;\n\n\n子组件中声明自定义事件\n12345&lt;script&gt;  export default &#123;    emits: [&#39;close&#39;]  &#125;&lt;&#x2F;script&gt;\n\n\n\n\n移除过滤器（filter）\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n\n\n…\n\n\n","thumbnail":"https://s2.loli.net/2022/02/21/Ziu2f9FQ34dLoIE.png","plink":"https://pinkpeachabc.cn/vue3/"},{"title":"Vue张天禹老师笔记","date":"2022-02-20T18:43:55.000Z","date_formatted":{"ll":"2022年2月21日","L":"2022/02/21","MM-DD":"02-21"},"author":"粉色桃子abc","updated":"2022-02-21T03:29:16.146Z","content":"尚硅谷 张天禹老师vue2笔记（方便自己查阅）\n\n[TOC]\n尚硅谷 张天禹老师vue2笔记\n脚手架文件结构\n12345678910111213141516├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件\n关于不同版本的Vue\n\nvue.js与vue.runtime.xxx.js的区别：\n\nvue.js是完整版的Vue，包含：核心功能 + 模板解析器。\nvue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。\n\n\n因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\nvue.config.js配置文件\n\n使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。\n使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh\n\nref属性\n\n被用来给元素或子组件注册引用信息（id的替代者）\n应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）\n使用方式：\n\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\nprops配置项\n\n\n功能：让组件接收外部传过来的数据\n\n\n传递数据：&lt;Demo name=&quot;xxx&quot;/&gt;\n\n\n接收数据：\n\n\n第一种方式（只接收）：props:['name']\n\n\n第二种方式（限制类型）：props:&#123;name:String&#125;\n\n\n第三种方式（限制类型、限制必要性、指定默认值）：\n1234567props:&#123;\tname:&#123;\ttype:String, //类型\trequired:true, //必要性\tdefault:&#x27;老王&#x27; //默认值\t&#125;&#125;\n\n\n\n备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\n\n\n\nmixin(混入)\n\n\n功能：可以把多个组件共用的配置提取成一个混入对象\n\n\n使用方式：\n第一步定义混合：\n12345&#123;    data()&#123;....&#125;,    methods:&#123;....&#125;    ....&#125;\n第二步使用混入：\n全局混入：Vue.mixin(xxx)\n​ 局部混入：mixins:['xxx']\n\n\n插件\n\n\n功能：用于增强Vue\n\n\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n\n\n定义插件：\n1234567891011121314对象.install = function (Vue, options) &#123;    // 1. 添加全局过滤器    Vue.filter(....)    // 2. 添加全局指令    Vue.directive(....)    // 3. 配置全局混入(合)    Vue.mixin(....)    // 4. 添加实例方法    Vue.prototype.$myMethod = function () &#123;...&#125;    Vue.prototype.$myProperty = xxxx&#125;\n\n\n使用插件：Vue.use()\n\n\nscoped样式\n\n作用：让样式在局部生效，防止冲突。\n写法：&lt;style scoped&gt;\n\n总结TodoList案例\n\n\n组件化编码流程：\n(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n1).一个组件在用：放在组件自身即可。\n2). 一些组件在用：放在他们共同的父组件上（状态提升）。\n(3).实现交互：从绑定事件开始。\n\n\nprops适用于：\n(1).父组件 ==&gt; 子组件 通信\n(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）\n\n\n使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\n\n\nprops传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n\n\nwebStorage\n\n\n存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n\n\n浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n\n相关API：\n\n\nxxxxxStorage.setItem('key', 'value');\n该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n\nxxxxxStorage.getItem('person');\n该方法接受一个键名作为参数，返回键名对应的值。\n\n\nxxxxxStorage.removeItem('key');\n该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n\nxxxxxStorage.clear()\n该方法会清空存储中的所有数据。\n\n\n\n\n备注：\n\nSessionStorage存储的内容会随着浏览器窗口关闭而消失。\nLocalStorage存储的内容，需要手动清除才会消失。\nxxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。\nJSON.parse(null)的结果依然是null。\n\n\n\n组件的自定义事件\n\n\n一种组件间通信的方式，适用于：子组件 ===&gt; 父组件\n\n\n使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。\n\n\n绑定自定义事件：\n\n\n第一种方式，在父组件中：&lt;Demo @atguigu=&quot;test&quot;/&gt;或 &lt;Demo v-on:atguigu=&quot;test&quot;/&gt;\n\n\n第二种方式，在父组件中：\n12345&lt;Demo ref=&quot;demo&quot;/&gt;......mounted()&#123;   this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test)&#125;\n\n\n若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n\n\n\n\n触发自定义事件：this.$emit('atguigu',数据)\n\n\n解绑自定义事件this.$off('atguigu')\n\n\n组件上也可以绑定原生DOM事件，需要使用native修饰符。\n\n\n注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n\n\n全局事件总线（GlobalEventBus）\n\n\n一种组件间通信的方式，适用于任意组件间通信。\n\n\n安装全局事件总线：\n1234567new Vue(&#123;\t......\tbeforeCreate() &#123;\t\tVue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\t&#125;,    ......&#125;) \n\n\n使用事件总线：\n\n\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。\n1234567methods()&#123;  demo(data)&#123;......&#125;&#125;......mounted() &#123;  this.$bus.$on(&#x27;xxxx&#x27;,this.demo)&#125;\n\n\n提供数据：this.$bus.$emit('xxxx',数据)\n\n\n\n\n最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n\n\n消息订阅与发布（pubsub）\n\n\n一种组件间通信的方式，适用于任意组件间通信。\n\n\n使用步骤：\n\n\n安装pubsub：npm i pubsub-js\n\n\n引入: import pubsub from 'pubsub-js'\n\n\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。\n1234567methods()&#123;  demo(data)&#123;......&#125;&#125;......mounted() &#123;  this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo) //订阅消息&#125;\n\n\n提供数据：pubsub.publish('xxx',数据)\n\n\n最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。\n\n\n\n\nnextTick\n\n语法：this.$nextTick(回调函数)\n作用：在下一次 DOM 更新结束后执行其指定的回调。\n什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。\n\nVue封装的过度与动画\n\n\n作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n\n\n图示：\n\n\n写法：\n\n\n准备好样式：\n\n元素进入的样式：\n\nv-enter：进入的起点\nv-enter-active：进入过程中\nv-enter-to：进入的终点\n\n\n元素离开的样式：\n\nv-leave：离开的起点\nv-leave-active：离开过程中\nv-leave-to：离开的终点\n\n\n\n\n\n使用&lt;transition&gt;包裹要过度的元素，并配置name属性：\n123&lt;transition name&#x3D;&quot;hello&quot;&gt;\t&lt;h1 v-show&#x3D;&quot;isShow&quot;&gt;你好啊！&lt;&#x2F;h1&gt;&lt;&#x2F;transition&gt;\n\n\n备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;，且每个元素都要指定key值。\n\n\n\n\nvue脚手架配置代理\n方法一\n在vue.config.js中添加如下配置：\n123devServer:&#123;  proxy:&quot;http://localhost:5000&quot;&#125;\n说明：\n\n优点：配置简单，请求资源时直接发给前端（8080）即可。\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理。\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）\n\n方法二\n编写vue.config.js配置具体代理规则：\n123456789101112131415161718192021module.exports = &#123;\tdevServer: &#123;      proxy: &#123;      &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api1&#x27;开头的请求路径        target: &#x27;http://localhost:5000&#x27;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125;      &#125;,      &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api2&#x27;开头的请求路径        target: &#x27;http://localhost:5001&#x27;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125;      &#125;    &#125;  &#125;&#125;/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080   changeOrigin默认值为true*/\n说明：\n\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理。\n缺点：配置略微繁琐，请求资源时必须加前缀。\n\n插槽\n\n\n作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===&gt; 子组件 。\n\n\n分类：默认插槽、具名插槽、作用域插槽\n\n\n使用方式：\n\n\n默认插槽：\n1234567891011父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;&#x2F;div&gt;        &lt;&#x2F;Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;&#x2F;slot&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;template&gt;\n\n\n具名插槽：\n123456789101112131415161718父组件中：        &lt;Category&gt;            &lt;template slot&#x3D;&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;&#x2F;div&gt;            &lt;&#x2F;template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;&#x2F;div&gt;            &lt;&#x2F;template&gt;        &lt;&#x2F;Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name&#x3D;&quot;center&quot;&gt;插槽默认内容...&lt;&#x2F;slot&gt;               &lt;slot name&#x3D;&quot;footer&quot;&gt;插槽默认内容...&lt;&#x2F;slot&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;template&gt;\n\n\n作用域插槽：\n\n\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n\n\n具体编码：\n1234567891011121314151617181920212223242526272829303132333435父组件中：\t\t&lt;Category&gt;\t\t\t&lt;template scope&#x3D;&quot;scopeData&quot;&gt;\t\t\t\t&lt;!-- 生成的是ul列表 --&gt;\t\t\t\t&lt;ul&gt;\t\t\t\t\t&lt;li v-for&#x3D;&quot;g in scopeData.games&quot; :key&#x3D;&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;\t\t\t\t&lt;&#x2F;ul&gt;\t\t\t&lt;&#x2F;template&gt;\t\t&lt;&#x2F;Category&gt;\t\t&lt;Category&gt;\t\t\t&lt;template slot-scope&#x3D;&quot;scopeData&quot;&gt;\t\t\t\t&lt;!-- 生成的是h4标题 --&gt;\t\t\t\t&lt;h4 v-for&#x3D;&quot;g in scopeData.games&quot; :key&#x3D;&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;h4&gt;\t\t\t&lt;&#x2F;template&gt;\t\t&lt;&#x2F;Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games&#x3D;&quot;games&quot;&gt;&lt;&#x2F;slot&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;template&gt;\t\t        &lt;script&gt;            export default &#123;                name:&#39;Category&#39;,                props:[&#39;title&#39;],                &#x2F;&#x2F;数据在子组件自身                data() &#123;                    return &#123;                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]                    &#125;                &#125;,            &#125;        &lt;&#x2F;script&gt;\n\n\n\n\n\n\nVuex\n1.概念\n在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n2.何时使用？\n多个组件需要共享数据时\n3.搭建vuex环境\n\n\n创建文件：src/store/index.js\n1234567891011121314151617181920//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = &#123;&#125;//准备mutations对象——修改state中的数据const mutations = &#123;&#125;//准备state对象——保存具体的数据const state = &#123;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate&#125;)\n\n\n在main.js中创建vm时传入store配置项\n1234567891011......//引入storeimport store from &#x27;./store&#x27;......//创建vmnew Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App),\tstore&#125;)\n\n\n4.基本使用\n\n\n初始化数据、配置actions、配置mutations，操作文件store.js\n12345678910111213141516171819202122232425262728293031323334//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123;    //响应组件中加的动作\tjia(context,value)&#123;\t\t// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)\t\tcontext.commit(&#x27;JIA&#x27;,value)\t&#125;,&#125;const mutations = &#123;    //执行加\tJIA(state,value)&#123;\t\t// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)\t\tstate.sum += value\t&#125;&#125;//初始化数据const state = &#123;   sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\n\n组件中读取vuex中的数据：$store.state.sum\n\n\n组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据)或 $store.commit('mutations中的方法名',数据)\n\n备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\n\n\n\n5.getters的使用\n\n\n概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n\n\n在store.js中追加getters配置\n12345678910111213......const getters = &#123;\tbigSum(state)&#123;\t\treturn state.sum * 10\t&#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\t......\tgetters&#125;)\n\n\n组件中读取数据：$store.getters.bigSum\n\n\n6.四个map方法的使用\n\n\n**mapState方法：**用于帮助我们映射state中的数据为计算属性\n1234567computed: &#123;    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;,\n\n\n**mapGetters方法：**用于帮助我们映射getters中的数据为计算属性\n1234567computed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法）    ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法）    ...mapGetters([&#x27;bigSum&#x27;])&#125;,\n\n\n**mapActions方法：**用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\n1234567methods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125;\n\n\n**mapMutations方法：**用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\n1234567methods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125;\n\n\n\n备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n\n7.模块化+命名空间\n\n\n目的：让代码更好维护，让多种数据分类更加明确。\n\n\n修改store.js\n12345678910111213141516171819202122232425const countAbout = &#123;  namespaced:true,//开启命名空间  state:&#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123;       return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced:true,//开启命名空间  state:&#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n\n\n开启命名空间后，组件中读取state数据：\n1234//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),\n\n\n开启命名空间后，组件中读取getters数据：\n1234//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])\n\n\n开启命名空间后，组件中调用dispatch\n1234//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n\n\n开启命名空间后，组件中调用commit\n1234//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n\n路由\n\n理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key是路径，value是组件。\n\n1.基本使用\n\n\n安装vue-router，命令：npm i vue-router\n\n\n应用插件：Vue.use(VueRouter)\n\n\n编写router配置项:\n12345678910111213141516171819202122//引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入Luyou 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)//暴露routerexport default router\n\n\n实现切换（active-class可配置高亮样式）\n1&lt;router-link active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;\n\n\n指定展示位置\n1&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n\n\n2.几个注意点\n\n路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route属性，里面存储着自己的路由信息。\n整个应用只有一个router，可以通过组件的$router属性获取到。\n\n3.多级路由（多级路由）\n\n\n配置路由规则，使用children配置项：\n1234567891011121314151617181920routes:[\t&#123;\t\tpath:&#x27;/about&#x27;,\t\tcomponent:About,\t&#125;,\t&#123;\t\tpath:&#x27;/home&#x27;,\t\tcomponent:Home,\t\tchildren:[ //通过children配置子级路由\t\t\t&#123;\t\t\t\tpath:&#x27;news&#x27;, //此处一定不要写：/news\t\t\t\tcomponent:News\t\t\t&#125;,\t\t\t&#123;\t\t\t\tpath:&#x27;message&#x27;,//此处一定不要写：/message\t\t\t\tcomponent:Message\t\t\t&#125;\t\t]\t&#125;]\n\n\n跳转（要写完整路径）：\n1&lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;\n\n\n4.路由的query参数\n\n\n传递参数\n12345678910111213&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\t\t\t\t&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link \t:to&#x3D;&quot;&#123;\t\tpath:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\t\tquery:&#123;\t\t   id:666,            title:&#39;你好&#39;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n\n接收参数：\n12$route.query.id$route.query.title\n\n\n5.命名路由\n\n\n作用：可以简化路由的跳转。\n\n\n如何使用\n\n\n给路由命名：\n1234567891011121314151617&#123;\tpath:&#x27;/demo&#x27;,\tcomponent:Demo,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;test&#x27;,\t\t\tcomponent:Test,\t\t\tchildren:[\t\t\t\t&#123;                      name:&#x27;hello&#x27; //给路由命名\t\t\t\t\tpath:&#x27;welcome&#x27;,\t\t\t\t\tcomponent:Hello,\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n\n简化跳转：\n12345678910111213141516&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to&#x3D;&quot;&#x2F;demo&#x2F;test&#x2F;welcome&quot;&gt;跳转&lt;&#x2F;router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to&#x3D;&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link \t:to&#x3D;&quot;&#123;\t\tname:&#39;hello&#39;,\t\tquery:&#123;\t\t   id:666,            title:&#39;你好&#39;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n\n\n\n6.路由的params参数\n\n\n配置路由，声明接收params参数\n1234567891011121314151617181920&#123;\tpath:&#x27;/home&#x27;,\tcomponent:Home,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;news&#x27;,\t\t\tcomponent:News\t\t&#125;,\t\t&#123;\t\t\tcomponent:Message,\t\t\tchildren:[\t\t\t\t&#123;\t\t\t\t\tname:&#x27;xiangqing&#x27;,\t\t\t\t\tpath:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数\t\t\t\t\tcomponent:Detail\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n\n传递参数\n12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;666&#x2F;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\t\t\t\t&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link \t:to&#x3D;&quot;&#123;\t\tname:&#39;xiangqing&#39;,\t\tparams:&#123;\t\t   id:666,            title:&#39;你好&#39;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n\n\n接收参数：\n12$route.params.id$route.params.title\n\n\n7.路由的props配置\n作用：让路由组件更方便的收到参数\n12345678910111213141516171819&#123;\tname:&#x27;xiangqing&#x27;,\tpath:&#x27;detail/:id&#x27;,\tcomponent:Detail,\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\t// props:&#123;a:900&#125;\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\t// props:true\t\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\tprops(route)&#123;\t\treturn &#123;\t\t\tid:route.query.id,\t\t\ttitle:route.query.title\t\t&#125;\t&#125;&#125;\n8.&lt;router-link&gt;的replace属性\n\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push\n如何开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt;\n\n9.编程式路由导航\n\n\n作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更加灵活\n\n\n具体编码：\n12345678910111213141516171819//$router的两个APIthis.$router.push(&#123;\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t\tid:xxx,\t\t\ttitle:xxx\t\t&#125;&#125;)this.$router.replace(&#123;\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t\tid:xxx,\t\t\ttitle:xxx\t\t&#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退\n\n\n10.缓存路由组件\n\n\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n\n具体编码：\n123&lt;keep-alive include&#x3D;&quot;News&quot;&gt;     &lt;router-view&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;keep-alive&gt;\n\n\n11.两个新的生命周期钩子\n\n作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n具体名字：\n\nactivated路由组件被激活时触发。\ndeactivated路由组件失活时触发。\n\n\n\n12.路由守卫\n\n\n作用：对路由进行权限控制\n\n\n分类：全局守卫、独享守卫、组件内守卫\n\n\n全局守卫:\n123456789101112131415161718192021222324//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123;\tconsole.log(&#x27;beforeEach&#x27;,to,from)\tif(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则\t\t\tnext() //放行\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t\t// next(&#123;name:&#x27;guanyu&#x27;&#125;)\t\t&#125;\t&#125;else&#123;\t\tnext() //放行\t&#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;afterEach&#x27;,to,from)\tif(to.meta.title)&#123; \t\tdocument.title = to.meta.title //修改网页的title\t&#125;else&#123;\t\tdocument.title = &#x27;vue_test&#x27;\t&#125;&#125;)\n\n\n独享守卫:\n12345678910111213beforeEnter(to,from,next)&#123;\tconsole.log(&#x27;beforeEnter&#x27;,to,from)\tif(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;\t\t\tnext()\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t\t// next(&#123;name:&#x27;guanyu&#x27;&#125;)\t\t&#125;\t&#125;else&#123;\t\tnext()\t&#125;&#125;\n\n\n组件内守卫：\n123456//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;\n\n\n13.路由器的两种工作模式\n\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\nhash模式：\n\n地址中永远带着#号，不美观 。\n若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。\n兼容性较好。\n\n\nhistory模式：\n\n地址干净，美观 。\n兼容性和hash模式相比略差。\n应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n\n\n\n","thumbnail":"https://s2.loli.net/2022/02/21/urxN5okIRMqLS8d.png","plink":"https://pinkpeachabc.cn/vue2/"},{"title":"Daily Life 2","date":"2021-04-20T15:21:02.000Z","date_formatted":{"ll":"2021年4月20日","L":"2021/04/20","MM-DD":"04-20"},"author":"粉色桃子abc","updated":"2021-04-22T03:43:12.335Z","content":"失踪人口回来啦🤗，前一篇还是元旦转眼已经将近五个月没写博客了，可以说是终极鸽子🕊怪了。\n消失\n年味刚过我的专升本考试就提上了日程，这几个月的时间都在备考当中。感觉每一天都在还高中的债，这三年光阴的对我来说可以说段瞬即逝，从大一的排斥到最后的释然。一个成长的过程，路程总是艰辛。直到今年三月底我终于完成我三年的盼望的一天，可以松口气睡个觉打个游戏了。考前一天还和同学在旅馆打趣说必定上岸换个好地方约占上网，还记的刚开始有许多同学在一起坚持，最后我的小圈子只剩一个人陪在身边了，有些人不知不觉中消失了。\n除草\n难得休憩的日子，也没有去找个兼职主要是懒。这两天一直受到服务器和域名到期的通知，一拍脑门已经把博客放的长满绿毛了。父亲在楼下地上种的瓜果蔬菜需要翻地，养分才能均匀更何况博客了。除草机也需要开几下了。\n\n全站替换 Https，续费域名。\n主题更新到了最新版本：2.7.0-beta.13。\n由于阿里云服务器 5 月分到期，不在继续续费改用 Vercel 作为托管。\n一直在用笔记本 15.6 寸，博客未能很好适配多分辨率的显示效果优化了显示范围。\n\n休闲\n这两天迷上了又重新入坑的炉石传说战令太香了，但是时间不如许高强度淦小时数。灵机一动使用脚本来刷，找了好久发现就只有一款叫 Hearthbuddy 的脚本软件。脚本用 C# 来写战斗策略配合 AI 计算实现挂机，一直以来对脚本的印象都是呆笨的，从现在起我正式向 AI 道歉。仅仅历时两个晚上，一路从青铜冲到低保恨不得没早用。\n学习\n躺的久了难免成为废人，关于技术栈这一方面已经搁置小半年没有学习了。搁的越久忘的越多，之后的日子从新开始快速学习。会更新一些学习笔记和日常生活。\n\n\n时间流逝，岁月不饶人。每个人都选择了的自己生活的方向，发小这星期也要结婚了。同学有的也陆续开始工作了，考研的也都已经在准备了。虽世殊事异，所以兴怀，其致一也。我想大家都如此吧，愿今后加油一切顺利。😊\n\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A28.png","plink":"https://pinkpeachabc.cn/日常小记/"},{"title":"Happy New Year","date":"2020-12-31T13:25:07.000Z","date_formatted":{"ll":"2020年12月31日","L":"2020/12/31","MM-DD":"12-31"},"author":"粉色桃子abc","updated":"2021-04-20T11:15:03.845Z","content":"新年快乐\n从前几天开始，手机上就开始不断推送各家的年终总结。本想着就着年末也写一篇自己的年终总结，但手指放到键盘才发现自己只是平淡的过完这一整年，基本上这一年大部分时光都是在家中度过的。\n\n疫情\n\n2020的第一天，突如其来的疫情，打破的我原本为今年定好的计划。因为疫情的影响从月初就被困在家里，接受的愉快的网课水课生活。日子一天天过去，疫情也渐渐好转。\n\n趣事\n\n在一个清晨，被警察👮叔叔找上门。人生第一次被警察叔叔找上门，还以为自己犯了什么错误。原来是来调查网站的用途和有无安全措施，填了张表就送走了。心里还是有点小紧张，现在的监管真的很严格，给👮‍点赞。\n\n学习\n\n忙完了学校的任务，今年的下半年基本都在紧张的复习和备考中，想要在计算机行业站住没有能力和学历各行各业都一样绝对是行不通的，期望专业课有个好成绩。\n\n计划\n\n今年在技能方面基本是处于一个停滞的状态，同时也在考虑今后的发展，和目前的能力适合选择什么样的方向。眼看比自己小一届的学弟已经可以独立开发项目上线，并在国赛取的优异的成绩了。自己还是平平无奇，期望一切顺利，计划在开发方向冲一冲。也是时候看看自己的极限在哪里。\n\n关于博客的更新，哈哈可能还要继续鸽下去。但我想时间不会太久，也祝愿小伙伴们新年快乐！\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A25.png","plink":"https://pinkpeachabc.cn/2021/"},{"title":"Daily life","date":"2020-09-09T15:26:33.000Z","date_formatted":{"ll":"2020年9月9日","L":"2020/09/09","MM-DD":"09-09"},"author":"粉色桃子abc","updated":"2021-04-20T11:00:18.656Z","content":"更新\n由于 hexo 已经升级到了 5.x.x 版本，inside主题会出现一些未知的 bug。本次已经升级到 hexo 5.1.1，主题更新到了最新版本：2.7.0-beta.3。\n另外在之前的设置的 valine 的邮箱回复，会出现未能唤醒的现象 “因流控原因，通过定时任务唤醒体验版实例失败，建议升级至标准版云引擎实例避免休眠”。本次通用 Github Action 修复了这个唤醒失败的错误。\n说明\n由于准备考试，今后的一个月不会更博，目前的 blog 整体度已经很高了。不会再折腾了以后说不定。总之要失踪一阵子了。\n\n今后争取写优质的原创文章、听几首好听的音乐、考一个理想的分数——2020年9月9日\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A21.png","plink":"https://pinkpeachabc.cn/小记/"},{"title":"Valine评论的邮箱提醒","date":"2020-08-06T05:21:28.000Z","date_formatted":{"ll":"2020年8月6日","L":"2020/08/06","MM-DD":"08-06"},"author":"粉色桃子abc","updated":"2021-04-20T10:59:50.547Z","content":"\n博客搭建了很久了，前两天闲来无事去逛别人博客时发现了别人给我发评论是可以用第三方邮件提醒。突然想起来自己的博客评论却没有这个功能，最早之前用过来必力很可惜加载龟速服务器不在国内，如今使用的是无后端的Valine，精简快捷。今天就给它设置个第三方邮件提醒吧。\n\n\n简介\n\n此项目是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。\n\nValine Admin\n配置\n\n首先进入Leancloud 中，在设置-邮件模板-用于重置密码的邮件主题中修改为：\n\n12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;你的网址首页链接&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt;\n\n\n部署Valine-Admin，在云引擎-部署-Git部署中输入 https://github.com/zhaojun1998/Valine-Admin ，并在分支或提交中输入master点击部署。\n\n\n\n接下来是配置项，在云引擎-设置-自定义环境变量中，添加新变量，如表所示：\n\n\n\n变量\n说明\n\n\n\n\nSITE_NAME\n[必填] 网站名称\n\n\nSITE_URL\n[必填] 网站地址，最后不要加 /\n\n\nSMTP_SERVICE\n[必填] 邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器\n\n\nSMTP_USER\n[必填] SMTP登录用户，一般为邮箱地址\n\n\nSMTP_PASS\n[必填] SMTP登录密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式\n\n\nSENDER_NAME\n[可选] 发件人\n\n\nADMIN_URL\n[建议] Web主机二级域名，用于自动唤醒\n\n\nTO_EMAIL\n[可选] 指定站长收信邮箱，默认值为SITE_USER。用于 SMTP 发件人与站长收件人不一致的情况下使用。\n\n\nTEMPLATE_NAME\n[可选] 通知邮件的模板（default和rainbow），参考高级功能\n\n\n\n\n关于几点注意：SMTP登录密码（例如qq），不是qq密码而是授权码。自定义环境变量保存完只有重启部署才有用。\n\n\n后台评论管理\n\n在设置-域名绑定-云引擎、ClientEngine 域名中，添加一个二级域名。\n\n\n\n在储存-结构化数据-_User中，点击添加行。只需要填写 email、password、username，这三个字段即可, 使用 email 作为账号登陆即可。\n\n\n\n在浏览器中输入你绑定的web域名，既可以访问到后台评论。\n\n\nLeanCloud 自带定时器[推荐]\n\n首先需要添加环境变量，ADMIN_URL：Web 主机域名，如图所示（添加后重启容器才会生效）：\n\n\n\n然后在云引擎-定时任务-创建定时任务中，新增定时器，如下图所示。\n\n\n\n注意, LeanCloud 最近更新了定时器校验规则, 需要将 Cron 表达式写为: 0 */20 7-23 * * ?\n\n测试\n用其他邮箱在自己的博客留言板出留言，进入邮箱看是否收到提醒。\n\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A23.png","plink":"https://pinkpeachabc.cn/Valine评论的邮箱提醒/"},{"title":"入手Y7000 & 黑苹果体验","date":"2020-07-24T04:02:18.000Z","date_formatted":{"ll":"2020年7月24日","L":"2020/07/24","MM-DD":"07-24"},"author":"粉色桃子abc","updated":"2021-04-20T11:17:55.344Z","content":"hey，我回来更博啦😝。最近在手头一开始忙疫情开学的事情一时抽不开时间，偷懒也是在乐在其中的哈哈。最近刚刚稳定下来准备明年的考试了，今天闲下来坐在电脑边时突然想到我还有个被遗忘的Mac系统，于是就有了今天的更新疯狂灌水。\n\n第一台笔记本电脑\n作为一个计算机专业，而且本身对硬件有所了解的一个大学生，对电子设备的选择往往是最纠结的。\n如今的笔电市场上，虽然说机型是遍地开花，但真要说值得买的却只有寥寥几种机型。做为一个学生可能看重的可能就是「性价比」了，我也不例外对于学生党来说一个不错的价格✚一个不错配置可谓是最好的选择。这时候你可能会大喊神舟大法好，可这你就错了。\n相比于游戏本我更喜欢商务本，当然并不是我的选择要Pass掉游戏本，毕竟游戏就目前来说也是生活的一部分csgo。言归正传，在商务本中能够我想的还是三大标杆XPS、苏菲、MBP。我一度疯狂迷恋XPS我觉得这是Windows端唯一和苹果抗衡的笔电了。\n当然你也许我会选择XPS，但最终综合考虑个人需求，经过对比，我选择了y7000。\n为什么会是Y7000？\n我最终还是败给了「贵」，同样的我也想要日常的游戏性能。于是另一款笔电就进入的我的眼帘——y7000。由于预算有限我购入的为高色域i5+GTX1650的版本，其实对于游戏玩家我还有个身份苹果粉，我一心想体验Macos，但价格目前是越不过的鸿沟。我转念一想我为何不选一款对黑苹果友好的游戏本，这也就是我在这个价位屏幕、模具、性能、散热等领域中选择的最佳。\n安装黑苹果\n话不多说，新机到手，先装系统。目前为Win10和MacOS Catalina双系统。就目前的状况来看基本达到了99%的完美。我使用的EFI是xiaoMGitHub的版本，目前除了声卡偶尔掉其他没有任何问题。目前支持的功能（需要更多请前往Github）：\n\nUEFI通过 Clover/OC 启动\n支持任意版本系统OTA升级到最新系统\n内置键盘以及数字键盘\n原生USB3.0/USB2.0\nAppleHDA原生音频，包括耳机\n内置摄像头\n原生电源管理\n电池状态\n背光控制\n背光键盘\n核显驱动（独显已经 hotpatch 屏蔽）\n有线以太网卡\nMac App Store正常运行\nCPU变频\n睡眠唤醒（鼠标，键盘、电源键唤醒均正常）\n无线网络（更换白果卡BCM943602cs）\n蓝牙（更换白果卡BCM943602cs）\n触控板 (部分低配机型不支持多指操作)\n随航（有线/无线）\n4K 屏幕（教程）\niMessage/FaceTime\n\n\n黑苹果体验\n从19年购入以来，我也渐渐使用了将近一年的黑苹果。给我感觉最大的是生态的优秀和对程序员的友好，优劣总是并存的，Mac对原生4k的支持是非常好的，但普通笔电15.6寸屏幕的效果就会略显模糊。未更换白果网卡将不会驱动wifi和蓝牙（Intel网卡部分现在已经驱动），在期间也是逛遍了远景和Github在经历了几次失败后，终于达到了几乎完美的状态。\n我卸载掉了黑苹果\n2020年7月24日也就是今天，我在长时间不使用黑苹果情况下，再次进入黑果，我忽然觉得我是时候和它说再见了。我是使用clover来引导的，用clover来引导进入日常的Windows端其实会有或多或少的性能损耗，长时间不用初次进入开机也是很缓慢的。\n硬盘的话我是用西数SN720，本想在买个硬盘装上各司其职，但出于经济考虑还是没有购买穷。于是一个硬盘安装了双系统，不知道是什么原因在温控都正常的情况下，在mac环境下硬盘的温度和噪音都在Windows之上。\n为什么想卸载掉这个系统了呢，其实最大的原因还是折腾。即使他看起来很完美，但实际上总会有一些小问题，就像睡觉时候一直有个蚊子在脑袋旁转，转的次数多了也就烦了。当然了在敲代码这方面和环境配置这点我觉得mac还是有绝对优势的，最主要的是美观和简洁，你可以全心全意的干你想做的事情在这个系统下。\n装黑苹果建议\n说你好和再见不过一年之久，即使不在使用它，我还是对这个系统保持着热情和喜爱，希望以后购入一台MBP来真正体验一下白苹果给人的感觉。同时对于初来乍到想安装并体验黑苹果的朋友，我建议大家在有精力和能力的基础上都建议尝试一下这种感觉，不仅仅是mac系统给你带来的快乐，还有安装过程中带来问题和惊喜。如果你正在考虑给你的机器装黑苹果，不妨去远景论坛和Github找找是否有和你配置相似的EFI，愿你最后也能吃上苹果！\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A26.png","plink":"https://pinkpeachabc.cn/黑苹果体验/"},{"title":"Spring框架详解","date":"2020-04-21T03:02:12.000Z","date_formatted":{"ll":"2020年4月21日","L":"2020/04/21","MM-DD":"04-21"},"updated":"2021-04-20T11:20:25.914Z","content":"\n距离上一次更新已经有一个月的时间了，😀其实本改把 Jdbc 的笔记补完，但是这些天事情太多忙着打csgo导致了博客这段时间没有更新。今天突然在网上找到了一篇关于Spring架构论述很好的文章，正好也是得更新一下。\n原文地址：Spring框架详解\n\nIOC 和 DI 的概述\nIOC(Inversion of Controll)\n思想是反转资源获取的方向，传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC之后，则是容器主动的将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接收资源\nDI(Dependency Injection)\n是IOC的另一种表述方式，即组件以一些预先定义好的方式(如：getter方法)来接收来自容器的资源注入\nSpring配置\n在SpringIOC容器读取bean配置创建bean实例之前，必须对它进行实例化。只有在容器实例化后，才可以从IOC容器里获取bean实例并使用\nSpring提供了两种类型的IOC容器实现\n\nBeanFactory：IOC容器的基本实现，在调用getBean()方法时才会实例化对象\nApplicationContext：提供了更多的高级特性，在加载配置文件后就会实例化对象。是BeanFactory的子接口\n\nBeanFactory是Spring框架的基础设施，面向Spring本身\n1ApplicationContext&#96;面向使用Spring框架的开发者，几乎所有的应用场合都直接使用&#96;ApplicationContext&#96;而非底层的&#96;BeanFactory\n无论使用何种方式，配置文件时都是相同的\n123456789101112131415161718192021222324252627282930313233343536&lt;!-- 配置bean --&gt;&lt;!-- class: bean的全类名，通过反射的方式在IOC容器中创建bean，所以要求bean中必须有无参构造器 --&gt;&lt;bean id=&quot;people&quot; class=&quot;learningspring.ioc.examples.People&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;Chen&quot;/&gt;&lt;/bean&gt;public class People &#123;    private String name;    public People() &#123;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;People&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;@Testpublic void test()&#123;    // 创建IOC容器    ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;F:\\\\Projects\\\\IdeaProjects\\\\LearningSpring\\\\src\\\\main\\\\java\\\\learningspring\\\\ioc\\\\examples\\\\applicationContext.xml&quot;);    // 从IOC容器中获取bean实例    People people = (People) ctx.getBean(&quot;people&quot;);    System.out.println(people);&#125;\nApplicationContext\nApplicationContext有两个实现类：\n\nClassPathXmlApplicationContext：加载类路径里的配置文件\nFileSystemXmlApplicationContext：加载文件系统里的配置文件\n\nBean的相关配置\nbean标签的id和name的配置\n\nid：使用了约束中的唯一约束。不能有特殊字符\nname：没有使用约束中的唯一约束（理论上可以重复，但是实际开发中不能出现）。可以有特殊字符\n\nbean的生命周期的配置\n\ninit-method：bean被初始化的时候执行的方法\ndestroy-method：bean被销毁的时候执行的方法，前提是bean是单例的，工厂关闭\n\nbean的作用范围的配置\n\nscope: bean的作用范围\nsingleton：单例模式，默认的作用域。\nprototype：多例模式。\nrequest：应用在Web项目中，Spring创建这个类后，将这个类存入到request范围中。\nsession：应用在Web项目中，Spring创建这个类后，将这个类存入到session范围中。\nglobalsession：应用在Web项目中，必须在porlet环境下使用。但是如果没有这种环境，相当于session。\n\nSpring的Bean管理配置\nSpring的Bean的实例化方式\n无参构造方式（默认）\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * //TODO * * @author Chen Rui * @version 1.0 **/public class Dog &#123;    private String name;    private Integer length;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getLength() &#123;        return length;    &#125;    public void setLength(Integer length) &#123;        this.length = length;    &#125;    @Override    public String toString() &#123;        return &quot;Dog&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, length=&quot; + length +                &#x27;&#125;&#x27;;    &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- Spring Bean的实例化方式--&gt;    &lt;!-- 无参构造的方式 --&gt;    &lt;bean id=&quot;dog&quot; class=&quot;learningspring.ioc.examples.demo3.Dog&quot;/&gt;&lt;/beans&gt;\n静态工厂实例化方式\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * * @author Chen Rui * @version 1.0 **/public class Car &#123;    private String name;    private Double price;    public Car() &#123;    &#125;    public Car(String name, Double price) &#123;        this.name = name;        this.price = price;    &#125;    @Override    public String toString() &#123;        return &quot;Car&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &#x27;&#125;&#x27;;    &#125;&#125;package learningspring.ioc.examples.demo3;/** * * @author Chen Rui * @version 1.0 **/public class CarFactory &#123;    public static Car createCar()&#123;        return new Car();    &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- Spring Bean的实例化方式--&gt;    &lt;!-- 静态工厂的方式 --&gt;    &lt;bean id=&quot;car&quot; class=&quot;learningspring.ioc.examples.demo3.CarFactory&quot; factory-method=&quot;createCar&quot;/&gt;&lt;/beans&gt;\n实例工厂实例化方式\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * //TODO * * @author Chen Rui * @version 1.0 **/public class Dog &#123;    private String name;    private Integer length;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getLength() &#123;        return length;    &#125;    public void setLength(Integer length) &#123;        this.length = length;    &#125;    @Override    public String toString() &#123;        return &quot;Dog&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, length=&quot; + length +                &#x27;&#125;&#x27;;    &#125;&#125;/** * //TODO * * @author Chen Rui * @version 1.0 **/public class DogFactory &#123;    public Dog createDog()&#123;        return new Dog();    &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- Spring Bean的实例化方式--&gt;    &lt;!-- 实例工厂的方式 --&gt;    &lt;bean id=&quot;dogFactory&quot; class=&quot;learningspring.ioc.examples.demo3.DogFactory&quot;/&gt;    &lt;bean id=&quot;dog2&quot; factory-bean=&quot;dogFactory&quot; factory-method=&quot;createDog&quot;/&gt;&lt;/beans&gt;\nSpring的属性注入方式\n构造方法方式的属性注入\n12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--构造方法方式的属性注入--&gt;    &lt;bean id=&quot;car&quot; class=&quot;learningspring.ioc.examples.demo3.Car&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;BWM&quot;/&gt;        &lt;constructor-arg name=&quot;price&quot; value=&quot;800000&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\nSet方法方式的属性注入\n1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--Set方法方式的属性注入--&gt;    &lt;bean id=&quot;dog&quot; class=&quot;learningspring.ioc.examples.demo3.Dog&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Golden&quot;/&gt;        &lt;property name=&quot;length&quot; value=&quot;100&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n为Bean注入引用类型的数据\n123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--构造方法方式的属性注入--&gt;    &lt;bean id=&quot;car&quot; class=&quot;learningspring.ioc.examples.demo3.Car&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;BWM&quot;/&gt;        &lt;constructor-arg name=&quot;price&quot; value=&quot;800000&quot;/&gt;    &lt;/bean&gt;    &lt;!--Set方法方式的属性注入--&gt;    &lt;bean id=&quot;dog&quot; class=&quot;learningspring.ioc.examples.demo3.Dog&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Golden&quot;/&gt;        &lt;property name=&quot;length&quot; value=&quot;100&quot;/&gt;    &lt;/bean&gt;    &lt;!--为Bean注入对象属性--&gt;    &lt;!--构造方法方式一样可行--&gt;    &lt;bean id=&quot;employee&quot; class=&quot;learningspring.ioc.examples.demo3.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Chen&quot;/&gt;        &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt;        &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\nP名称空间的属性注入（Spring2.5）\n\n通过引入p名称空间完成属性注入\n\n普通属性：p:属性名=“值”\n对象属性：p:属性名-ref=“值”\n\n\n\n12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--P名称空间的属性注入--&gt;    &lt;bean id=&quot;cat&quot; class=&quot;learningspring.ioc.examples.demo3.Cat&quot; p:name=&quot;Orange&quot; p:length=&quot;100&quot;/&gt;        &lt;!--为Bean注入对象属性--&gt;    &lt;bean id=&quot;employee&quot; class=&quot;learningspring.ioc.examples.demo3.Employee&quot; p:cat-ref=&quot;cat&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Chen&quot;/&gt;        &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt;        &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\nSpEL方式的属性注入（Spring3）\nSpEL：Spring Expresssion Language 的表达式语言\n语法：#{表达式}\n1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--SpEL表达式注入--&gt;    &lt;bean id=&quot;cat2&quot; class=&quot;learningspring.ioc.examples.demo4.Cat&quot;&gt;        &lt;!--字符串要加单引号--&gt;        &lt;!--也可以通过#&#123;beanName.属性名或方法名&#125;来通过其他bean的属性或者方法来注入--&gt;        &lt;property name=&quot;name&quot; value=&quot;#&#123;&#x27;Orange&#x27;&#125;&quot;/&gt;        &lt;property name=&quot;length&quot; value=&quot;#&#123;101&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n注入集合类型的数据\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 注入集合类型的数据测试 * * @author Chen Rui * @version 1.0 **/public class CollectionBean &#123;    private String[] strs;    private List&lt;String&gt; list;    private Set&lt;String&gt; set;    private Map&lt;String, String&gt; map;    public void setStrs(String[] strs) &#123;        this.strs = strs;    &#125;    public void setList(List&lt;String&gt; list) &#123;        this.list = list;    &#125;    public void setSet(Set&lt;String&gt; set) &#123;        this.set = set;    &#125;    public void setMap(Map&lt;String, String&gt; map) &#123;        this.map = map;    &#125;    @Override    public String toString() &#123;        return &quot;CollectionBean&#123;&quot; +                &quot;strs=&quot; + Arrays.toString(strs) +                &quot;, list=&quot; + list +                &quot;, set=&quot; + set +                &quot;, map=&quot; + map +                &#x27;&#125;&#x27;;    &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--Spring的集合属性的注入--&gt;    &lt;!--注入数组类型--&gt;    &lt;bean id=&quot;collectionBean&quot; class=&quot;learningspring.ioc.examples.demo4.CollectionBean&quot;&gt;        &lt;!-- 注入数组类型 --&gt;        &lt;property name=&quot;strs&quot;&gt;            &lt;list&gt;                &lt;value&gt;Tom&lt;/value&gt;                &lt;value&gt;Jack&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;!-- 注入List集合 --&gt;        &lt;property name=&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;Lucy&lt;/value&gt;                &lt;value&gt;Lily&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;!-- 注入Set集合 --&gt;        &lt;property name=&quot;set&quot;&gt;            &lt;set&gt;                &lt;value&gt;aaa&lt;/value&gt;                &lt;value&gt;bbb&lt;/value&gt;                &lt;value&gt;ccc&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;!-- 注入Map集合 --&gt;        &lt;property name=&quot;map&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;a&quot; value=&quot;1&quot;/&gt;                &lt;entry key=&quot;b&quot; value=&quot;2&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\nSpring分模块开发的配置\n\n加载配置文件时，直接加载多个配置文件\n\n1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;);\n\n在一个配置文件中引入多个配置文件\n\n123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--引入配置文件--&gt;\t&lt;import resource=&quot;applicationContext2.xml&quot;/&gt;    &lt;/beans&gt;\nSpring开发中的常用注解\n@Component\n该注解在类上使用，使用该注解就相当于在配置文件中配置了一个Bean，例如：\n1234567@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;UserDaoImpl.save&quot;);    &#125;&#125;\n相当于以下内容：\n1&lt;bean id=&quot;userDao&quot; class=&quot;learningspring.ioc.examplesannotation.demo1.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n该注解有3个衍生注解：\n\n@Controller：修饰Web 层类\n@Service：修饰Service层类\n@Repository：修饰Dao层类\n\n@Value\n该注解用于给属性注入值，有2种用法\n\n如果有set方法，则需要将该注解添加到set方法上\n如果没有set方法，则需要将该注解添加到属性上\n\n1234567891011121314151617181920212223242526272829303132333435363738394041/** * Value 注解用于属性注入 * 当类有提供set方法时添加在set方法上 * 如果没有，则添加到属性上 * * @author Chen Rui * @version 1.0 **/@Component(&quot;dog&quot;)public class Dog &#123;    private String name;    @Value(&quot;100&quot;) // 注入属性值    private Double length;    public Dog() &#123;    &#125;    public Dog(String name, Double length) &#123;        this.name = name;        this.length = length;    &#125;    public String getName() &#123;        return name;    &#125;    @Value(&quot;Golden&quot;) // 注入属性值    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Dog&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, length=&quot; + length +                &#x27;&#125;&#x27;;    &#125;&#125;\n@Autowired\n@Value 通常用于普通属性的注入。\n@Autowired 通常用于为对象类型的属性注入值，但是按照类型完成属性注入\n习惯是按照名称完成属性注入，所以必须让@Autowired注解和@Qualifier注解一同使用。\n（如果没有@Qualifier注解，修改以下例子中@Repository注解的值，也能编译成功）\n1234567891011121314151617181920@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123;    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;    @Override    public void save() &#123;        System.out.println(&quot;UserServiceImpl.save&quot;);        userDao.save();    &#125;&#125;@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;UserDaoImpl.save&quot;);    &#125;&#125;\n@Resource\n该注解也可以用于属性注入，通常情况下使用**@Resource注解**，默认按照名称完成属性注入。\n该注解由J2EE提供，需要导入包javax.annotation.Resource。\n@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * UserController * * @author Chen Rui * @version 1.0 **/@Controller(&quot;userController&quot;)public class UserController &#123;        @Resource(name = &quot;userService&quot;)    private UserService userService;     &#125;/** * UserService实现类 * * @author Chen Rui * @version 1.0 **/@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123;\t@Resource(name = &quot;userDao&quot;)    private UserDao userDao;    @Override    public void save() &#123;        System.out.println(&quot;UserServiceImpl.save&quot;);        userDao.save();    &#125;&#125;/** * UserDao实现类 * @author Chen Rui * @version 1.0 **/@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;UserDaoImpl.save&quot;);    &#125;&#125;\n@PostConstruct 和 @PreDestroy\n@PostConstruct和@PreDestroy注解，前者为Bean生命周期相关的注解，在配置文件中，使用到了init-method参数来配置Bean初始化之前要执行的方法，该注解也是同样的作用。将该注解添加到想在初始化之前执行的目标方法上，就可以实现该功能，而后者则是Bean生命周期中destroy-method目标方法，使用该注解在指定方法上，即可实现在Bean销毁之前执行该方法。\n123456789101112131415161718192021222324/** * UserDao实现类 * @author Chen Rui * @version 1.0 **/@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;        @PostConstruct    public void init()&#123;        System.out.println(&quot;UserDaoImpl.init&quot;);    &#125;        @Override    public void save() &#123;        System.out.println(&quot;UserDaoImpl.save&quot;);    &#125;        @PreDestroy    public void destroy()&#123;        System.out.println(&quot;UserDaoImpl.destroy&quot;);    &#125;&#125;\n@Scope\nBean的作用范围的注解，默认为singleton（单例）\n可选值：\n\nsingleton\nprototype\nrequest\nsession\nglobalsession\n\n12345678910111213141516171819202122232425/** * UserDao实现类 * @author Chen Rui * @version 1.0 **/@Component(&quot;userDao&quot;)@Scope // 默认为singletonpublic class UserDaoImpl implements UserDao &#123;    @PostConstruct    public void init()&#123;        System.out.println(&quot;UserDaoImpl.init&quot;);    &#125;    @Override    public void save() &#123;        System.out.println(&quot;UserDaoImpl.save&quot;);    &#125;    @PreDestroy    public void destroy()&#123;        System.out.println(&quot;UserDaoImpl.destroy&quot;);    &#125;&#125;\n基于XML配置和基于注解配置的对比\n\n\n\n基于XML的配置\n基于注解的配置\n\n\n\n\nBean的定义\n\n@Component或衍生注解@Controller，@Service和@Repository\n\n\nBean的名称\n通过id或name指定\n@Component(“Bean的id”)\n\n\nBean的属性注入\n或者通过p命名空间\n通过注解@Autowired 按类型注入 通过@Qualifier按名称注入\n\n\nBean的生命周期\ninit-method指定Bean初始化前执行的方法，destroy-method指定Bean销毁前执行的方法\n@PostConstruct 对应于int-method @PreDestroy 对应于destroy-method\n\n\nBean的作用域\n在bean标签中配置scope属性\n@Scope, 默认是singleton 配置多例可以在目标类上使用@Scope(“prototype”)\n\n\n使用场景\nBean来自第三方，可以使用在任何场景\nBean的实现类由自己维护\n\n\nXML可以适用于任何场景，就算Bean来自第三方也可以适用XML方式来管理。而注解方式就无法在此场景下使用，注解方式可以让开发的过程更加方便，但前提是Bean由自己维护，这样才能在源码中添加注解。\n所以可以使用两者混合的方式来开发项目，使用XML配置文件来管理Bean，使用注解来进行属性注入\nSpring AOP\nAOP的概述\n即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\nAOP的案例（应用场景）\n背景：某项目已经写好了保存到数据库的方法。假设现在需要添加一个新的功能，例如权限校验，在保存到数据库之前要对用户权限进行校验。\n123456public class UserDaoImpl implements UserDao &#123;    @Override    public void save()&#123;        ...    &#125;&#125;\n现在需要多加一个需求，在用户将数据保存到数据库之前，进行权限校验。\n此时通常就会在该方法中添加一个方法来进行权限校验然后在save方法中调用。\n1234567891011public class UserDaoImpl implements UserDao &#123;    @Override    public void save()&#123;        checkPri();        // 保存到数据库    &#125;        private void checkPri()&#123;        // 权限校验    &#125;&#125;\n用这样的方法来实现，弊端就是只能在这一个类中使用，通常一个项目中有许多的方法都可能需要执行权限校验，此时就要在每个类中编写同样的代码，所以该方法并不科学。\n此时就有了一个更好的方法，即纵向继承。\n定义一个通用的Dao，在通用的Dao中编写权限校验的方法。\n12345public class BaseDao&#123;    public void checkPri()&#123;        // 权限校验    &#125;&#125;\n然后每一个不同的类都去继承这个类，再调用该方法\n1234567public class UserDaoImpl extends BaseDao implements UserDao&#123;    @Override    public void save()&#123;        checkPri();        // 保存到数据库    &#125;&#125;\n此时就只需要维护BaseDao中的一份代码就可以，大大减轻了工作量，提高了效率。\n但AOP的思想更高一步，不采用纵向继承，而采用横向抽取来取代\n123456public class UserDaoImpl implements UserDao&#123;    @Override    public void save()&#123;        // 保存到数据库    &#125;&#125;\n横向抽取机制实质上就是代理机制，通过创建UserDaoImpl类的代理类，通过代理类来调用权限校验的方法。\nAOP底层实现原理\nAOP的实现使用了动态代理技术，动态代理分为两种\n\nJDK动态代理：只能对实现了接口的类产生代理\nCglib动态代理（类似于javassist的第三方代理技术）：对没有实现接口的类产生代理对象，即生成子类对象。\n\nJDK动态代理\nJDK动态代理案例\n该案例实现一个计算器的日志功能\n首先创建一个接口Calculator\n12345678910111213141516171819202122232425262728293031323334353637383940/** * 计算器接口 * * @author Chen Rui * @version 1.0 **/public interface Calculator &#123;    /**     * 加法     * @param a 实数     * @param b 实数     * @return 相加结果     */    int add(int a, int b);    /**     * 减法     * @param a 实数,被减数     * @param b 实数,减数     * @return 相减结果     */    int sub(int a, int b);    /**     * 乘法     * @param a 实数     * @param b 实数     * @return 相乘结果     */    int mul(int a, int b);    /**     * 除法     * @param a 实数,被除数     * @param b 实数,除数     * @return 相除结果     */    int div(int a, int b);&#125;\n接着创建一个类CalculatorImpl来实现该接口并重写方法\n1234567891011121314151617181920212223242526272829303132/** * 计算器实现类 * * @author Chen Rui * @version 1.0 **/public class CalculatorImpl implements Calculator &#123;    @Override    public int add(int a, int b) &#123;        return a + b;    &#125;    @Override    public int sub(int a, int b) &#123;        return a - b;    &#125;    @Override    public int mul(int a, int b) &#123;        return a * b;    &#125;    @Override    public int div(int a, int b) &#123;        if (b == 0)&#123;            System.out.println(&quot;除数不能为0&quot;);            return 0;        &#125;        return  a / b;    &#125;&#125;\n在测试类中测试该计算器代码\n1234567891011121314151617181920/** * @author Chen Rui * @version 1.0 **/public class AppTest &#123;        @Test    public void test() &#123;        Calculator target = new CalculatorImpl();        int a = 10;        int b = 10;        System.out.println(&quot;res --&gt; &quot; + target.add(a, b));        System.out.println(&quot;res --&gt; &quot; + target.mul(a, b));        System.out.println(&quot;res --&gt; &quot; + target.sub(a, b));        System.out.println(&quot;res --&gt; &quot; + target.div(a, b));    &#125;&#125;\n此时控制台的输出结果为：\n1234res --&gt; 20res --&gt; 100res --&gt; 0res --&gt; 1\n现在为该计算器增加打印日志的功能\n创建一个计算器的代理类CalculatorLoggingProxy，在类中首先定义被代理的目标对象target，并通过构造函数进行赋值。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;import java.util.Date;/** * 计算器代理类 * 实现扩展打印日志功能 * * @author Chen Rui * @version 1.0 **/public class CalculatorProxy &#123;    /**     * 被代理的对象     */    private Calculator target;    public CalculatorProxy(Calculator target) &#123;        this.target = target;    &#125;    public Calculator createProxy()&#123;        Calculator proxy;        ClassLoader classLoader = target.getClass().getClassLoader();        Class[] interfaces = new Class[]&#123;Calculator.class&#125;;        InvocationHandler handler = new InvocationHandler() &#123;            /**             * @param proxy     正在返回的代理对象，一般在invoke方法中都不使用该对象             *                  如果使用该对象，则会引发栈内存溢出。因为会循环调用invoke方法。             * @param method    正在被调用的方法             * @param args      调用方式时传入的参数             * @return             * @throws Throwable             */            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                // 获取方法名                String methodName = method.getName();                // 输出日志逻辑                System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(args));                // 执行方法                Object result = method.invoke(target, args);                // 输出日志逻辑                System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; ends with &quot; + result);                return result;            &#125;        &#125;;        proxy = (Calculator) Proxy.newProxyInstance(classLoader,interfaces,handler);        return proxy;    &#125;&#125;\n此时重新编写测试方法\n12345678910111213141516171819202122/** * @author Chen Rui * @version 1.0 **/public class AppTest &#123;        @Test    public void test() &#123;        Calculator target = new CalculatorImpl();        // 创建代理对象        Calculator proxy = new CalculatorProxy(target).createProxy();        int a = 10;        int b = 10;        System.out.println(&quot;res --&gt; &quot; + proxy.add(a, b));        System.out.println(&quot;res --&gt; &quot; + proxy.mul(a, b));        System.out.println(&quot;res --&gt; &quot; + proxy.sub(a, b));        System.out.println(&quot;res --&gt; &quot; + proxy.div(a, b));    &#125;&#125;\n到此就完成了在不改变CalculatorImpl类的源代码的情况下，实现对计算器的功能增加，实现了日志打印的功能。此时控制台的打印内容为\n123456789101112Sun Mar 17 20:36:26 CST 2019: The method add begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method add ends with 20res --&gt; 20Sun Mar 17 20:36:26 CST 2019: The method mul begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method mul ends with 100res --&gt; 100Sun Mar 17 20:36:26 CST 2019: The method sub begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method sub ends with 0res --&gt; 0Sun Mar 17 20:36:26 CST 2019: The method div begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method div ends with 1res --&gt; 1\nCglib动态代理\nCglib动态代理案例\n同样来实现一个对计算器来增加打印日志功能\n首先创建计算器类Calculator\n12345678910111213141516171819202122232425262728/** * 计算器类 * * @author Chen Rui * @version 1.0 **/public class Calculator &#123;    public int add(int a, int b) &#123;        return a + b;    &#125;    public int sub(int a, int b) &#123;        return a - b;    &#125;    public int mul(int a, int b) &#123;        return a * b;    &#125;    public int div(int a, int b) &#123;        if (b == 0)&#123;            System.out.println(&quot;除数不能为0&quot;);            return 0;        &#125;        return  a / b;    &#125;&#125;\n此时需要导入cglib的jar包，在maven中添加依赖\n12345&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;\n接着创建计算器的代理类CalculatorProxy并且实现MethodInterceptor接口并重写intercept方法。\n在类中首先定义被代理的目标对象，并通过构造函数进行赋值。然后创建createProxy()方法返回被增强的计算器对象。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 计算器代理类 * * @author Chen Rui * @version 1.0 **/public class CalculatorProxy implements MethodInterceptor &#123;    /**     * 被代理的对象     */    private Calculator target;    public CalculatorProxy(Calculator target) &#123;        this.target = target;    &#125;    public Calculator createProxy()&#123;        // 1.创建cglib的核心类对象        Enhancer enhancer = new Enhancer();        // 2.设置父类        enhancer.setSuperclass(target.getClass());        // 3.设置回调（类似于jdk动态代理中的InvocationHandler对象）        enhancer.setCallback(this);        // 4.创建代理对象        Calculator proxy = (Calculator) enhancer.create();        return proxy;    &#125;    @Override    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;        // 获取方法名        String methodName = method.getName();        // 输出日志逻辑        System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(args));        // 执行方法        Object result = methodProxy.invokeSuper(proxy, args);        // 输出日志逻辑        System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; ends with &quot; + result);        return result;    &#125;&#125;\nSpring中的AOP实现——AspectJ\nAOP开发中的相关术语\n123456789public class UserDao&#123;    public void save()&#123;&#125;        public void query()&#123;&#125;        public void update()&#123;&#125;        public void delete()&#123;&#125;&#125;\n\njoinpoint(连接点) ： 可以被拦截到的点。save(), query(),update(),delete()方法都可以增强，这些方法就可以称为连接点。\npointcut(切入点)：真正被拦截到的点。在实际开发中，可以只对save()方法进行增强，那么save()方法就是切入点。\nadvice(增强)：方法层面的增强，现在可以对save()方法进行权限校验，权限校验(checkPri())的方法称为增强。\nintroduction(引介)：类层面的增强。\ntarget(目标)：被增强的对象。\nweaving(织入)：将增强(advice)应用到目标(target)的过程\nproxy(代理)：代理对象，被增强以后的代理对象\naspect(切面)：多个增强(advice)和多个切入点(pointcut)的组合\n\nAspectJ的XML配置案例\n首先创建一个接口ProductDao，在里面定义添加商品，查询商品，修改商品，删除商品方法。\n12345678910111213141516171819202122232425262728/** * ProductDao * * @author Chen Rui * @version 1.0 **/public interface ProductDao &#123;    /**     * 添加商品     */    void save();    /**     * 删除商品     */    void delete();    /**     * 修改商品     */    void modify();    /**     * 查询商品     */    void query();&#125;\n接着创建一个类ProductDaoImpl来实现该接口\n1234567891011121314151617181920212223242526272829/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;添加商品&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;删除商品&quot;);    &#125;        @Override    public void modify() &#123;        System.out.println(&quot;修改商品&quot;);    &#125;        @Override    public void query() &#123;        System.out.println(&quot;查询商品&quot;);    &#125;    &#125;\n现在目的就是给save()方法进行增强，使得在调用save()方法前进行权限校验。\n要实现此功能，先创建一个增强类，或者叫切面类。里面编写要增强的功能，例如权限校验。\n创建增强类ProductEnhancer\n12345678910111213/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123;    public void checkPri()&#123;        System.out.println(&quot;【前置增强】权限校验&quot;);    &#125;&#125;\n然后创建配置文件aspectj-xml.xml来配置，该文件名此案例仅用于演示，实际开发中不要采取此名，依据实际需求编写。\n12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置目标对象，即被增强的对象 --&gt;    &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt;    &lt;!-- 将增强类(切面类)交给Spring管理 --&gt;    &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt;        &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt;    &lt;aop:config&gt;        &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt;        &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt;        &lt;!--        “*” 表示任意返回值类型        “..” 表示任意参数        --&gt;        &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt;        &lt;!-- 配置切面 --&gt;        &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt;            &lt;!-- 前置增强 --&gt;            &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt;            &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;/beans&gt;\n至此切入点及切面都已配置完成，编写测试类和方法\n123456789101112131415161718192021222324252627282930313233import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * AspectJ的XML方式配置测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:aspectj-xml.xml&quot;)public class AppTest &#123;    @Resource(name = &quot;productDao&quot;)    private ProductDao productDao;    @Test    public void test()&#123;        // 对save方法进行增强        productDao.save();        productDao.delete();                productDao.modify();                productDao.query();    &#125;&#125;\n运行test()方法，控制台打印结果如下：\n12345【前置增强】权限校验添加商品删除商品修改商品查询商品\n至此就实现了在不修改ProductDaoImpl类的情况下，对其中的save()方法进行增强。\nSpring中常用的增强类型\n前置增强\n在目标方法执行之前执行，可以获得切入点的信息\n修改之前的ProductEnhancer类的checkPri()方法的参数。\n123456789101112131415import org.aspectj.lang.JoinPoint;/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123;    public void checkPri(JoinPoint joinPoint)&#123;        System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint);    &#125;&#125;\n执行测试方法，控制台输出\n12345【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品修改商品查询商品\n后置增强\n在目标方法执行之后执行，可以获得方法的返回值\n首先修改ProductDao中的delete()方法的返回值类型，改成String\n12345678910111213141516171819202122232425262728/** * ProductDao * * @author Chen Rui * @version 1.0 **/public interface ProductDao &#123;    /**     * 添加商品     */    void save();    /**     * 删除商品     */    String delete();    /**     * 修改商品     */    void modify();    /**     * 查询商品     */    void query();&#125;\n再修改ProductDaoImpl中的delete()方法\n1234567891011121314151617181920212223242526272829/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;添加商品&quot;);    &#125;    @Override    public String delete() &#123;        System.out.println(&quot;删除商品&quot;);        return new Date().toString();    &#125;    @Override    public void modify() &#123;        System.out.println(&quot;修改商品&quot;);    &#125;    @Override    public void query() &#123;        System.out.println(&quot;查询商品&quot;);    &#125;&#125;\n修改ProductEnhancer类，添加writeLog()方法，实现写日志功能\n1234567891011121314151617181920212223242526/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123;    /**     * 前置增强案例     * 在调用save方法之前进行权限校验     * @param joinPoint 切入点对象     */    public void checkPri(JoinPoint joinPoint)&#123;        System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint);    &#125;    /**     * 后置增强案例     * 在调用delete方法之后，写入日志记录操作时间     * @param result 目标方法返回的对象     */    public void writeLog(Object result)&#123;        System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString());    &#125;&#125;\n然后修改aspectj.xml配置文件，配置新的切入点和切面\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置目标对象，即被增强的对象 --&gt;    &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt;    &lt;!-- 将增强类(切面类)交给Spring管理 --&gt;    &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt;        &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt;    &lt;aop:config&gt;        &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt;        &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt;        &lt;!--        “*” 表示任意返回值类型        “..” 表示任意参数        --&gt;        &lt;!-- 前置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt;                &lt;!-- 后置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt;        &lt;!-- 配置切面 --&gt;        &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt;            &lt;!-- 前置增强 --&gt;            &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt;            &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;                        &lt;!-- 后置增强 --&gt;            &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt;            &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n执行测试方法，控制台打印结果\n123456【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:59:48 CST 2019修改商品查询商品\n环绕增强\n在目标方法执行之前和之后都执行\n利用环绕增强来实现在调用modify()方法前后进行性能监控\n首先修改ProductEnhancer类，添加monitor()方法\n123456789101112131415161718192021222324252627282930313233343536373839/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123;    /**     * 前置增强案例     * 在调用save方法之前进行权限校验     * @param joinPoint 切入点对象     */    public void checkPri(JoinPoint joinPoint)&#123;        System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint);    &#125;    /**     * 后置增强案例     * 在调用delete方法之后，写入日志记录操作时间     * @param result 目标方法返回的对象     */    public void writeLog(Object result)&#123;        System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString());    &#125;    /**     * 环绕增强     * 在调用modify方法前后，显示性能参数     * @param joinPoint 切入点对象     * @throws Throwable 可抛出的异常     */    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123;        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        Object obj = joinPoint.proceed();        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        return obj;    &#125;&#125;\n然后再修改aspectj.xml配置文件，添加新的切入点和切面\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置目标对象，即被增强的对象 --&gt;    &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt;    &lt;!-- 将增强类(切面类)交给Spring管理 --&gt;    &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt;        &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt;    &lt;aop:config&gt;        &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt;        &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt;        &lt;!--        “*” 表示任意返回值类型        “..” 表示任意参数        --&gt;        &lt;!-- 前置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt;        &lt;!-- 后置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt;        &lt;!-- 环绕增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut3&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.modify(..))&quot;/&gt;        &lt;!-- 配置切面 --&gt;        &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt;            &lt;!-- 前置增强 --&gt;            &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt;            &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;!-- 后置增强 --&gt;            &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt;            &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt;            &lt;!-- 环绕增强 --&gt;            &lt;aop:around method=&quot;monitor&quot; pointcut-ref=&quot;pointcut3&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n运行测试方法，控制台打印结果：\n12345678【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:58:49 CST 2019【环绕增强】当前空闲内存185MB修改商品【环绕增强】当前空闲内存185MB查询商品\n异常抛出增强\n在程序出现异常时执行\n利用异常抛出增强来实现获取异常信息的功能\n首先修改ProductDaoImpl中的query()方法，使该方法抛出异常\n123456789101112131415161718192021222324252627282930/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;添加商品&quot;);    &#125;    @Override    public void query() &#123;        System.out.println(&quot;查询商品&quot;);        int a = 1/0;    &#125;    @Override    public void modify() &#123;        System.out.println(&quot;修改商品&quot;);    &#125;    @Override    public String delete() &#123;        System.out.println(&quot;删除商品&quot;);        return new Date().toString();    &#125;&#125;\n接着修改ProductEnhancer类，添加exception()方法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123;    /**     * 前置增强案例     * 在调用save方法之前进行权限校验     * @param joinPoint 切入点对象     */    public void checkPri(JoinPoint joinPoint)&#123;        System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint);    &#125;    /**     * 后置增强案例     * 在调用delete方法之后，写入日志记录操作时间     * @param result 目标方法返回的对象     */    public void writeLog(Object result)&#123;        System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString());    &#125;    /**     * 环绕增强     * 在调用modify方法前后，显示性能参数     * @param joinPoint 切入点对象     * @throws Throwable 可抛出的异常     */    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123;        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        Object obj = joinPoint.proceed();        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        return obj;    &#125;    /**     * 异常抛出增强     * 在调用query时若抛出异常则打印异常信息     * @param ex 异常对象     */    public void exception(Throwable ex)&#123;        System.out.println(&quot;【异常抛出增强】&quot; + &quot;异常信息：&quot; +ex.getMessage());    &#125;&#125;\n然后再修改aspectj-xml.xml配置文件，添加新的切入点和切面\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置目标对象，即被增强的对象 --&gt;    &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt;    &lt;!-- 将增强类(切面类)交给Spring管理 --&gt;    &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt;        &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt;    &lt;aop:config&gt;        &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt;        &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt;        &lt;!--        “*” 表示任意返回值类型        “..” 表示任意参数        --&gt;        &lt;!-- 前置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt;        &lt;!-- 后置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt;        &lt;!-- 环绕增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut3&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.modify(..))&quot;/&gt;        &lt;!-- 异常抛出增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut4&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.query(..))&quot;/&gt;        &lt;!-- 配置切面 --&gt;        &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt;            &lt;!-- 前置增强 --&gt;            &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt;            &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;!-- 后置增强 --&gt;            &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt;            &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt;            &lt;!-- 环绕增强 --&gt;            &lt;aop:around method=&quot;monitor&quot; pointcut-ref=&quot;pointcut3&quot;/&gt;            &lt;!-- 异常抛出增强 --&gt;            &lt;aop:after-throwing method=&quot;exception&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointcut4&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n最后执行测试方法，控制台输出结果：\n123456789【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:58:16 CST 2019【环绕增强】当前空闲内存183MB修改商品【环绕增强】当前空闲内存183MB查询商品【异常抛出增强】异常信息：&#x2F; by zero\n最终增强\n无论代码是否有异常最终都会执行\n继续在异常抛出增强的代码修改，实现无论是否抛出异常都会打印当前时间信息\n首先修改ProductEnhancer类，添加finallyAdvice()方法\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123;    /**     * 前置增强案例     * 在调用save方法之前进行权限校验     * @param joinPoint 切入点对象     */    public void checkPri(JoinPoint joinPoint)&#123;        System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint);    &#125;    /**     * 后置增强案例     * 在调用delete方法之后，写入日志记录操作时间     * @param result 目标方法返回的对象     */    public void writeLog(Object result)&#123;        System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString());    &#125;    /**     * 环绕增强     * 在调用modify方法前后，显示性能参数     * @param joinPoint 切入点对象     * @throws Throwable 可抛出的异常     */    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123;        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        Object obj = joinPoint.proceed();        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        return obj;    &#125;    /**     * 异常抛出增强     * 在调用query时若抛出异常则打印异常信息     * @param ex 异常对象     */    public void exception(Throwable ex)&#123;        System.out.println(&quot;【异常抛出增强】&quot; + &quot;异常信息：&quot; +ex.getMessage());    &#125;    /**     * 最终增强     * 无论query方法是否抛出异常都打印当前时间     */    public void finallyAdvice()&#123;        System.out.println(&quot;【最终增强】&quot; + new Date().toString());    &#125;&#125;\n修改aspectj.xml配置文件，添加新的切面\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置目标对象，即被增强的对象 --&gt;    &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt;    &lt;!-- 将增强类(切面类)交给Spring管理 --&gt;    &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt;        &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt;    &lt;aop:config&gt;        &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt;        &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt;        &lt;!--        “*” 表示任意返回值类型        “..” 表示任意参数        --&gt;        &lt;!-- 前置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt;        &lt;!-- 后置增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt;        &lt;!-- 环绕增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut3&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.modify(..))&quot;/&gt;        &lt;!-- 异常抛出增强的切入点配置 --&gt;        &lt;aop:pointcut id=&quot;pointcut4&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.query(..))&quot;/&gt;        &lt;!-- 配置切面 --&gt;        &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt;            &lt;!-- 前置增强 --&gt;            &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt;            &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;            &lt;!-- 后置增强 --&gt;            &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt;            &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt;            &lt;!-- 环绕增强 --&gt;            &lt;aop:around method=&quot;monitor&quot; pointcut-ref=&quot;pointcut3&quot;/&gt;            &lt;!-- 异常抛出增强 --&gt;            &lt;aop:after-throwing method=&quot;exception&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointcut4&quot;/&gt;            &lt;!-- 最终增强 --&gt;            &lt;aop:after method=&quot;finallyAdvice&quot; pointcut-ref=&quot;pointcut4&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n最后运行测试代码，控制台输出结果：\n12345678910【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:57:01 CST 2019【环绕增强】当前空闲内存183MB修改商品【环绕增强】当前空闲内存183MB查询商品【最终增强】Tue Mar 19 15:57:01 CST 2019【异常抛出增强】异常信息：&#x2F; by zero\nAOP切入点表达式语法\nAOP切入点表达式是基于execution的函数完成的\n语法：[访问修饰符] 方法返回值 包名.类名.方法名(参数)\n“*” 表示任意返回值类型 “…” 表示任意参数\n\npublic void learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..)：具体到某个增强的方法\n* *.*.*.*Dao.save(..)：所有包下的所有以Dao结尾的类中的save方法都会被增强\n* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl+.save(..)：ProductDaoImpl及其子类的save方法都会被增强\n* learningspring.aop.aspectj.xml..*.*(..)：xml包及其子包的所有类的方法都会被增强\n\nAspectJ的注解配置案例\n首先也是创建一个接口ProductDao\n12345678910111213141516171819202122232425262728/** * ProductDao接口 * * @author Chen Rui * @version 1.0 **/public interface ProductDao &#123;    /**     * 添加商品     */    void save();    /**     * 查询商品     */    void query();    /**     * 修改商品     */    void modify();    /**     * 删除商品     */    String delete();&#125;\n然后创建一个Dao实现类ProductDaoImpl\n123456789101112131415161718192021222324252627282930/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;添加商品&quot;);    &#125;    @Override    public String delete() &#123;        System.out.println(&quot;删除商品&quot;);        return new Date().toString();    &#125;    @Override    public void modify() &#123;        System.out.println(&quot;修改商品&quot;);    &#125;    @Override    public void query() &#123;        System.out.println(&quot;查询商品&quot;);        int a = 1/0;    &#125;&#125;\n接着创建增强类ProductEnhancer，在该类里面使用注解\n使用@Pointcut注解可以配置切入点信息，在较多的方法都要使用同一个增强时，就可以配置一个切入点让目标方法都去引用\n@Before：前置增强\n@AfterReturning：后置增强，其中的returning的值必须和方法传入的参数名相同\n@Around：环绕增强\n@AfterThrowing：异常抛出增强，其中的throwing的值必须和方法传入的参数名相同\n@After：最终增强\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/@Aspectpublic class ProductEnhancer &#123;    /**     * 切入点配置     * 对ProductDaoImpl里的方法都增强     */    @Pointcut(value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.*(..))&quot;)    private void pointcut1()&#123;&#125;    /**     * 前置增强案例     * 在调用save方法之前进行权限校验     * @param joinPoint 切入点对象     */    @Before(value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.save())&quot;)    public void checkPri(JoinPoint joinPoint)&#123;        System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint);    &#125;    /**     * 后置增强案例     * 在调用delete方法之后，写入日志记录操作时间     * @param result 目标方法返回的对象     */    @AfterReturning(returning = &quot;result&quot;, value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.delete())&quot;)    public void writeLog(Object result)&#123;        System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString());    &#125;    /**     * 环绕增强     * 在调用modify方法前后，显示性能参数     * @param joinPoint 切入点对象     * @throws Throwable 可抛出的异常     */    @Around(value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.modify())&quot;)    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123;        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        Object obj = joinPoint.proceed();        System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;);        return obj;    &#125;    /**     * 异常抛出增强     * 在调用query时若抛出异常则打印异常信息     * @param ex 异常对象     */    @AfterThrowing(throwing = &quot;ex&quot;, value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.query())&quot;)    public void exception(Throwable ex)&#123;        System.out.println(&quot;【异常抛出增强】&quot; + &quot;异常信息：&quot; +ex.getMessage());    &#125;    /**     * 最终增强     * 无论ProductDaoImpl里的每个方法是否抛出异常都打印当前时间     */    @After(value = &quot;pointcut1()&quot;)    public void finallyAdvice()&#123;        System.out.println(&quot;【最终增强】&quot; + new Date().toString());    &#125;&#125;\n编写测试方法\n1234567891011121314151617181920212223242526/** * AspectJ的注解方式配置测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:aspectj-annotation.xml&quot;)public class AppTest &#123;    @Resource(name = &quot;productDao&quot;)    private ProductDao productDao;    @Test    public void test()&#123;        productDao.save();        productDao.delete();        productDao.modify();        productDao.query();    &#125;&#125;\n运行，控制台输出\n12345678910111213【前置增强】权限校验execution(void learningspring.aop.aspectj.annotation.demo2.ProductDao.save())添加商品【最终增强】Tue Mar 19 16:01:06 CST 2019删除商品【最终增强】Tue Mar 19 16:01:06 CST 2019【后置增强】写入日志 操作时间：Tue Mar 19 16:01:06 CST 2019【环绕增强】当前空闲内存186MB修改商品【环绕增强】当前空闲内存186MB【最终增强】Tue Mar 19 16:01:06 CST 2019查询商品【最终增强】Tue Mar 19 16:01:06 CST 2019【异常抛出增强】异常信息：&#x2F; by zero\nSpring JDBC Template\nSpring提供了提供了多种持久层技术的模板类\n\n\nORM持久化技术\n模板类\n\n\n\n\nJDBC\norg.springframework.jdbc.core.JdbcTemplate\n\n\nHibernate3.0\norg.springframework.orm.hibernate3.HibernateTemplate\n\n\nIBatis(Mybatis)\norg.springframework.orm.ibatis.SqlMapClientTemplate\n\n\nJPA\norg.springframework.orm.jpa.JpaTemplate\n\n\nJDBC Template的入门\n首先引入jar包，在pom.xml文件中加入spring-jdbc，spring-tx，mysql-connector-java（本案例使用的是MySQL8）三个依赖。\n1234567891011121314151617&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;\n然后创建数据库表，本例使用的MySQL8\n12345678create table account(\tid int auto_increment\t\tprimary key,\tname varchar(8) not null,\tmoney double default 0)comment &#39;账户表&#39;;\n基本使用\n最基本的使用，不依赖于Spring 的管理，手动创建对象，采用硬编码的方式进行属性注入。不推荐使用该方法。\n1234567891011121314151617181920public class AppTest &#123;    /**     * 硬编码     */    @Test    public void test1()&#123;        // 创建连接池        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/springjdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false &quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        // 创建JDBC Template        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        int i = jdbcTemplate.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Tom&quot;, 20000d);        if (i &gt; 0)&#123;            System.out.println(&quot;Update Successful&quot;);        &#125;    &#125;&#125;\n接下来使用第二种方法，把连接池对象和模板(Template)都交给Spring来管理\n创建spring-jdbc.xml该文件用来管理Bean\n12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/springjdbc?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useSSL=false&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Spring JDBC Template --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n在测试类中加入相应的注解，以及配置文件信息，编写新的测试方法\n12345678910111213141516171819202122232425/** * Spring JDBC Template的使用 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)public class AppTest &#123;    /**     * Spring 配置文件方式     * 把连接池和模板(Template)都交给spring管理     * 日志信息：Loaded JDBC driver: com.mysql.cj.jdbc.Driver     * 是使用的默认的连接池     */    @Resource(name = &quot;jdbcTemplate&quot;)    private JdbcTemplate jdbcTemplate;    @Test    public void test2()&#123;        int i = jdbcTemplate.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Jack&quot;, 30000d);        if (i &gt; 0)&#123;            System.out.println(&quot;Update Successful&quot;);        &#125;    &#125;\n通过@Resource注解从IOC容器中获取到模板对象，然后通过该模板对象来操作数据库。\n这样就完成了Spring JDBC Template的最基本使用\n数据库连接池\n在实际开发中，可能并不会使用默认的连接池，而是去使用一些开源的数据库连接池，在该例中介绍两种数据库连接池DBCP和C3P0\nDBCP连接池的配置\n首先创建连接数据库的配置文件db.properties，注意，不同的MySQL版本可能url信息会不同，比如MySQL8就需要添加serverTimezone参数。\n1234jdbc.driverClassName=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false jdbc.username=rootjdbc.password=123456\n接着创建一个新的配置文件spring-dbcp.xml和前面的配置文件做区分。\n利用context:property-placeholder标签引入db.properties配置文件，通过$&#123;key&#125;的方式来获取对应的value。\n12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 引入数据库配置文件 --&gt;    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;    &lt;!-- 配置DBCP连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Spring JDBC Template --&gt;    &lt;bean id=&quot;jdbcTemplateDBCP&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n编写测试方法\n12345678910111213141516171819202122232425/** * Spring JDBC Template的使用 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-dbcp.xml&quot;)public class AppTest &#123;    //使用开源的数据库连接池进行配置    /**     * 使用DBCP连接池     */    @Resource(name = &quot;jdbcTemplateDBCP&quot;)    private JdbcTemplate jdbcTemplateDBCP;    @Test    public void test3()&#123;        int i = jdbcTemplateDBCP.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Lucy&quot;, 40000d);        if (i &gt; 0)&#123;            System.out.println(&quot;Update Successful&quot;);        &#125;    &#125;&#125;\nC3P0连接池配置\n同样是创建一个新的配置文件spring-c3p0.xml，以作区分，同时也要引入数据库配置文件db.properties\n要注意property标签的name属性和前面的配置文件稍有不同\n12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd\thttp://www.springframework.org/schema/context\thttp://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 引入数据库配置文件 --&gt;    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;    &lt;!-- 配置C3P0连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Spring JDBC Template --&gt;    &lt;bean id=&quot;jdbcTemplateC3P0&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n编写测试方法\n12345678910111213141516171819202122232425/** * Spring JDBC Template的使用 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-*.xml&quot;)public class AppTest &#123;    //使用开源的数据库连接池进行配置    /**     * 使用C3P0连接池     */    @Resource(name = &quot;jdbcTemplateC3P0&quot;)    private JdbcTemplate jdbcTemplateC3P0;    @Test    public void test4()&#123;        int i = jdbcTemplateC3P0.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Lily&quot;, 50000d);        if (i &gt; 0)&#123;            System.out.println(&quot;Update Successful&quot;);        &#125;    &#125;&#125;\n完成基本的CRUD操作\n以下内容都是使用的C3P0连接池，并且通过@Resource注解从IOC容器中获取了jdbcTemplateC3P0对象\n插入操作\n12345678910/** * 插入操作 */@Testpublic void test()&#123;    int i = jdbcTemplateC3P0.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Lily&quot;, 50000d);    if (i &gt; 0)&#123;        System.out.println(&quot;Update Successful&quot;);    &#125;&#125;\n修改操作\n12345678910/** * 修改操作 */@Testpublic void test()&#123;    int i = jdbcTemplateC3P0.update(&quot;UPDATE account SET name = ? WHERE id = ?&quot;, &quot;Bob&quot;, 1);    if (i &gt; 0)&#123;        System.out.println(&quot;Update Successful&quot;);    &#125;&#125;\n删除操作\n12345678910/** * 删除操作 */@Testpublic void test()&#123;    int i = jdbcTemplateC3P0.update(&quot;DELETE FROM account WHERE id = ?&quot;, 2);    if (i &gt; 0)&#123;        System.out.println(&quot;Delete Successful&quot;);    &#125;&#125;\n查询操作\n查询某个属性\n123456789101112131415161718192021222324/** * 查询操作 * * 查询单个字符串结果 */@Testpublic void test()&#123;    String result = jdbcTemplateC3P0.queryForObject(&quot;SELECT name FROM account WHERE id = ?&quot;, String.class, 1);    if (result != null)&#123;        System.out.println(result);    &#125; else&#123;        System.out.println(&quot;NULL&quot;);    &#125;&#125;/** * 统计查询 * 返回数据表中的记录数 */@Testpublic void test()&#123;    Long result = jdbcTemplateC3P0.queryForObject(&quot;SELECT COUNT(*) FROM account&quot;, Long.class);    System.out.println(result);&#125;\n查询返回单个对象\n要实现查询的数据封装成一个对象的话，查询queryForObject的参数列表可知需要一个rowMapper的参数。所以需要创建一个执行数据封装的类来实现RowMapper接口里的mapRow方法，在这个方法里进行数据对象的封装。\n12345678910111213141516/** * 数据封装类 * * @author Chen Rui * @version 1.0 **/public class MyRowMapper implements RowMapper&lt;Account&gt; &#123;    @Override    public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        Account account = new Account();        account.setId(rs.getInt(&quot;id&quot;));        account.setName(rs.getString(&quot;name&quot;));        account.setMoney(rs.getDouble(&quot;money&quot;));        return account;    &#125;&#125;\n编写测试方法\n12345678910111213/** * 将查询的结果封装成对象 * 要创建一个自定义rowMapper来实现RowMapper接口 */@Testpublic void test()&#123;    Account account = jdbcTemplateC3P0.queryForObject(&quot;SELECT * FROM account WHERE id = ?&quot;, new MyRowMapper(), 1);    if (account != null)&#123;        System.out.println(account);    &#125; else&#123;        System.out.println(&quot;NULL&quot;);    &#125;&#125;\n查询返回对象集合\n要实现查询返回对象集合依然需要自定义类实现RowMapper接口，调用的是query方法\n12345678/** * 查询多条记录 */@Testpublic void test10()&#123;    List&lt;Account&gt; accounts = jdbcTemplateC3P0.query(&quot;SELECT * FROM account&quot;, new MyRowMapper());    accounts.forEach(System.out::println);&#125;\nSpring事务管理\n什么是事务\n事务：逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部失败。\n事务的特性\n\n原子性：事务不可分割\n一致性：事务执行前后数据完整性保持一致\n隔离性：一个事务的执行不应该受到其他事务的干扰\n持久性：一旦事务结束，数据就持久化到数据库\n\n不考虑隔离性引发的安全性问题\n\n读问题\n\n脏读：A事务读到B事务未提交的数据\n不可重复读：B事务在A事务两次读取数据之间，修改了数据，导致A事务两次读取结果不一致\n幻读/虚读：B事务在A事务批量修改数据时，插入了一条新的数据，导致数据库中仍有一条数据未被修改。\n\n\n写问题\n\n丢失更新：\n\n\n\n解决读问题\n\n设置事务的隔离级别\n\nRead uncommitted：未提交读，任何读问题都解决不了\nRead committed：已提交读，解决脏读，但是不可重复读和幻读有可能发生\nRepeatable read：重复读，解决脏读和不可重复读，但是幻读有可能发生\nSerializable：解决所有读问题，因为禁止并行执行\n\n\n\nSpring事务管理API\n\n\nPlatformTransactionManager：平台事务管理器\n\nDataSourceTransactionManager：底层使用JDBC管理事务\n\n\n\nTransactionDefinition：事务定义信息\n用于定义事务相关的信息，隔离级别，超时信息，传播行为，是否只读……\n\n\nTransactionStatus：事务的状态\n用于记录在事务管理过程中，事务的状态\n\n\nAPI的关系：\nSpring在进行事务管理的时候，首先平台事务管理器根据事务定义信息进行事务的管理，在事务管理过程中，产生各种状态，将这些状态信息记录到事务状态对象\nSpring事务的传播行为\n首先假设一个背景，Service1里的x()方法已经定义了一个事务，Service2里的y()方法也有一个事务，但现在新增一行代码在Service2的y()方法中要先调用Service1里的x()方法然后再执行本身的方法。这时就涉及到事务的传播行为。\n\nSpring中提供了7种传播行为\n假设x()方法称为A，y()方法称为B\n\n保证多个操作在同一个事务中\n\nPROPAGATION_REQUIRED(*)：Spring事务隔离级别的默认值。如果A中有事务，则使用A中的事务。如果没有，则创建一个新的事务，将操作包含进来。\nPROPAGATION_SUPPORTS：支持事务。如果A中有事务，使用A中的事务。如果A没有事务，则不使用事务。\nPROPAGATION_MANDATORY：如果A中有事务，使用A中的事务。如果没有事务，则抛出异常。\n\n\n保证多个事务不在同一个事务中\n\nPROPAGATION_REQUIRES_NEW(*)：如果A中有事务，将A的事务挂起，创建新事务，只包含自身操作。如果A中没有事务，创建一个新事物，包含自身操作。\nPROPAGATION_NOT_SUPPORTED：如果A中有事务，将A的事务挂起，不使用事务。\nPROPAGATION_NEVER：如果A中有事务，则抛出异常。\n\n\n嵌套式事务\n\nPROPAGATION_NESTED(*)：嵌套事务，如果A中有事务，则按照A的事务执行，执行完成后，设置一个保存点，再执行B中的操作，如果无异常，则执行通过，如果有异常，则可以选择回滚到初始位置或者保存点。\n\n\n\nSpring事务管理案例——转账情景\n转账情景实现\n首先创建接口AccountDao，定义两个方法分别是out和in\n12345678910111213141516171819202122232425/** * AccountDao * * @author Chen Rui * @version 1.0 **/public interface AccountDao &#123;    /**     * 转出     *     * @param from  转出账户     * @param money 转出金额     */    void out(String from, double money);    /**     * 转入     *     * @param to    转入账户     * @param money 转入金额     */    void in(String to, double money);&#125;\n接着创建实现类AccountDaoImpl实现out和in方法并且继承JdbcSupport类。这样就可以直接使用父类的JDBCTemplate对象。\n123456789101112131415161718/** * AccountDao实现类 * * @author Chen Rui * @version 1.0 **/public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123;    @Override    public void out(String from, double money) &#123;        this.getJdbcTemplate().update(&quot;UPDATE account SET money = money - ? WHERE name = ?&quot;, money, from);    &#125;    @Override    public void in(String to, double money) &#123;        this.getJdbcTemplate().update(&quot;UPDATE account SET money = money + ? WHERE name = ?&quot;, money, to);    &#125;&#125;\n然后创建接口AccountrService，定义transfer方法\n12345678910111213141516/** * AccountService * * @author Chen Rui * @version 1.0 **/public interface AccountService &#123;    /**     * 转账     * @param from 转出账户     * @param to 转入账户     * @param money 交易金额     */    void transfer(String from, String to, Double money);&#125;\n再创建类AccountServiceImpl实现该接口，并声明AccountDao引用并创建set方法\n1234567891011121314151617181920/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService &#123;    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(String from, String to, Double money) &#123;        accountDao.out(from, money);        accountDao.in(to, money);    &#125;&#125;\n最后创建配置文件spring-tx-programmatic.xml，用来管理Bean。\n引入数据库连接文件，配置数据源，创建Bean对象accountDao将数据源dataSource注入到accountDao中，再创建Bean对象accountService，将accountDao注入。\n123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;                                                         http://www.springframework.org/schema/beans              http://www.springframework.org/schema/beans/spring-beans.xsd              http://www.springframework.org/schema/context               http://www.springframework.org/schema/context/spring-context.xsd              http://www.springframework.org/schema/tx             http://www.springframework.org/schema/tx/spring-tx.xsd            http://www.springframework.org/schema/aop            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 编程式事务管理配置文件 --&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.programmatic.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Dao --&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.programmatic.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 引入数据库配置文件 --&gt;    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;    &lt;!-- 配置C3P0连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n到此一个转账模拟业务就实现了，数据库表依然使用前面创建的account表，先查询当前数据库的数据。\n\n编写测试方法，实现让姓名为Bob的账户向Jack转账1000元。\n123456789101112131415161718/** * 编程式事务测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value = &quot;classpath:spring-tx-programmatic.xml&quot;)public class AppTest &#123;    @Resource(name = &quot;accountService&quot;)    private AccountService accountService;    @Test    public void test()&#123;        accountService.transfer(&quot;Bob&quot;,&quot;Jack&quot;,1000d);    &#125;&#125;\n运行结果\n\n现在对类AccountServiceImpl里的transfer方法进行修改，让其发生异常，再观察结果\n1234567891011121314151617181920212223/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService &#123;    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(String from, String to, Double money) &#123;        accountDao.out(from, money);        // 抛出异常        int i = 1/0;        accountDao.in(to, money);    &#125;&#125;\n查询数据库数据\n\n这时Bob账户的钱就少了1000元，而Jack账户也没有增加1000元。\n所以就需要事务来进行管理。\n编程式事务\n所谓编程式事务，就是要在源码中编写事务相关的代码。实现编程式事务，首先要在AccountServiceImpl中声明TransactionTemplate对象，并创建set方法。然后修改transfer参数列表所有参数都用final(因为使用了匿名内部类)修饰，并修改方法体内容。\n1234567891011121314151617181920212223242526272829303132/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService &#123;    private AccountDao accountDao;    private TransactionTemplate transactionTemplate;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123;        this.transactionTemplate = transactionTemplate;    &#125;    @Override    public void transfer(final String from, final String to, final Double money) &#123;        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;            @Override            protected void doInTransactionWithoutResult(TransactionStatus status) &#123;                accountDao.out(from, money);                // 抛出异常                int i = 1/0;                accountDao.in(to,money);            &#125;        &#125;);    &#125;&#125;\n然后修改spring-tx-programmatic.xml文件，创建Bean对象transactionManager和transactionTemplate，并将transactionTemplate注入到accountService中。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;                                                         http://www.springframework.org/schema/beans              http://www.springframework.org/schema/beans/spring-beans.xsd              http://www.springframework.org/schema/context               http://www.springframework.org/schema/context/spring-context.xsd              http://www.springframework.org/schema/tx             http://www.springframework.org/schema/tx/spring-tx.xsd            http://www.springframework.org/schema/aop            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 编程式事务管理配置文件 --&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.programmatic.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;        &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Dao --&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.programmatic.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 引入数据库配置文件 --&gt;    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;    &lt;!-- 配置C3P0连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置模板 --&gt;    &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n此时异常依然存在，数据库数据仍然是上次执行的结果状态\n\n再次运行测试方法，并查询结果，观察是否发生变化\n\n现在就实现了编程式事务，当出现异常时，数据库的数据就不会被修改。\n声明式事务\nXML配置方式\n声明式事务即通过配置文件实现，利用的就是Spring的AOP\n修改类AccountServiceImpl，删除TransactionTemplate对象，并修改transfer方法，保留异常代码\n12345678910111213141516171819202122/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService&#123;    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(String from, String to, Double money) &#123;        accountDao.out(from, money);        int i = 1/0;        accountDao.in(to,money);    &#125;&#125;\n然后创建配置文件spring-tx-declarative.xml，配置数据源即Bean对象，然后配置事务管理器。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;            http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd            http://www.springframework.org/schema/context            http://www.springframework.org/schema/context/spring-context.xsd            http://www.springframework.org/schema/tx            http://www.springframework.org/schema/tx/spring-tx.xsd            http://www.springframework.org/schema/aop            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 声明式事务管理配置文件 --&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.declarative.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Dao --&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.declarative.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 引入数据库配置文件 --&gt;    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;    &lt;!-- 配置C3P0连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n接着就配置事务的增强，配置文件中加入以下配置\n12345678910111213&lt;!-- 配置事务的增强 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;!-- 配置事务的规则 根据实际业务修改--&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- AOP的配置 --&gt;&lt;aop:config&gt;    &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.transaction.declarative.AccountServiceImpl.*(..))&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;&lt;/aop:config&gt;\n先查看当前数据库数据\n\n编写测试方法\n123456789101112131415161718/** * 声明式事务配置测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value = &quot;classpath:spring-tx-declarative.xml&quot;)public class AppTest &#123;    @Resource(name = &quot;accountService&quot;)    private AccountService accountService;    @Test    public void test()&#123;        accountService.transfer(&quot;Bob&quot;,&quot;Jack&quot;,1000d);    &#125;&#125;\n运行查看结果，是否变化\n\n至此就实现了声明式事务XML方式的配置。\n注解配置方式\nSpring的事务配置仍然支持注解配置\n继续沿用spring-tx-declarative.xml文件，把事务增强和AOP相关的配置注释，并开启注解事务。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;            http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd            http://www.springframework.org/schema/context            http://www.springframework.org/schema/context/spring-context.xsd            http://www.springframework.org/schema/tx            http://www.springframework.org/schema/tx/spring-tx.xsd            http://www.springframework.org/schema/aop            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 声明式事务管理配置文件 --&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.declarative.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置Dao --&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.declarative.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 引入数据库配置文件 --&gt;    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;    &lt;!-- 配置C3P0连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 配置事务的增强 --&gt;    &lt;!--&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;--&gt;        &lt;!--&lt;tx:attributes&gt;--&gt;            &lt;!-- 配置事务的规则 --&gt;            &lt;!--&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;--&gt;        &lt;!--&lt;/tx:attributes&gt;--&gt;    &lt;!--&lt;/tx:advice&gt;--&gt;    &lt;!-- AOP的配置 --&gt;    &lt;!--&lt;aop:config&gt;--&gt;        &lt;!--&lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.transaction.declarative.AccountServiceImpl.*(..))&quot;/&gt;--&gt;        &lt;!--&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;--&gt;    &lt;!--&lt;/aop:config&gt;--&gt;        &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;\n接下来就可以在业务层类上使用事务管理的注解了。修改AccountServiceImpl类，添加@Transactional注解\n123456789101112131415161718192021222324/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/@Transactional(rollbackFor = Exception.class)public class AccountServiceImpl implements AccountService&#123;    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(String from, String to, Double money) &#123;        accountDao.out(from, money);        int i = 1/0;        accountDao.in(to,money);    &#125;&#125;\n再次运行测试方法，数据库也不会发生改变。\n","thumbnail":"https://cdn.jsdelivr.net/gh/pinkpeachabc/images/Blog-imgs/%E5%8D%9A%E5%AE%A27.png","plink":"https://pinkpeachabc.cn/IOC 和 DI 的概述/"},{"title":"EL与JSTL","date":"2020-03-08T13:18:24.000Z","date_formatted":{"ll":"2020年3月8日","L":"2020/03/08","MM-DD":"03-08"},"updated":"2020-07-18T13:08:53.737Z","content":"经历过了 JSP，发现既能写 Html 又能写 Java 代码确实很方便，但是对于JSP 内部脚本的编写，却是很不友好😭 今天来介绍能够替代 JSP 页面中的脚本——EL 与 JSTL\nEL表达式\n作用\n\nEL最主要的作用是获得四大域中的数据\n\n从四大域当中取数据\npageContext\n1$&#123;pageScope.key&#125;;\nrequest\n1$&#123;requestScope.key&#125;\nsession\n1$&#123;sessionScope.key&#125;\napplication\n1$&#123;applicationScope.key&#125;\n简写\n1$&#123;EL表达式&#125;\n\nEL 从四个域中获得某个值 ${key}，依次从 pageContext 域，request 域，session 域，application 域中，获取属性在某个域中获取后将不在向后寻找。\n\nEL 内置 11 对象\npageScope\n获取 JSP 中 pageScope 域中的数据\nrequestScope\n获取 JSP 中 requestScope 域中的数据\nsessionScope\n获取 JSP 中 sessionScope 域中的数据\napplicationScope\n获取 JSP 中 applicationScope 域中的数据\nparam\nrequest.getParameter()\nparamValues\nrquest.getParameterValues()\nheader\nrequest.getHeader(name)\nheaderValues\nrequest.getHeaderValues()\ninitParam\nthis.getServletContext().getInitParameter(name)\ncookie\t\nrequest.getCookies()---cookie.getName()---cookie.getValue()\npageContext\npageContext 获得其他八大对象，获取当前项目的名称\n$&#123;pageContext.request.contextPath&#125;\nEL 执行表达式\n\n内部可以进行运算，只要有结果\n\n123$&#123;1+1&#125;$&#123;empty user&#125;$&#123;user==null?true:false&#125;\nJSTL\n什么是JSTL\n\nJSTL（JSP Standard Tag Library)，JSP 标准标签库。可以嵌入在 jsp 页面中使用标签的形式完成业务逻辑等功能，jstl 出现的目的同el一样也是要代替 jsp 页面中的脚本代码。\n\n导包和引入\n使用 jstl 需要先把 jar 包引入工程当中 (jstl-1.2.jar)，然后引入标签库才能够继续使用。\n1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;\nif 标签\n&lt;c:if test=&quot;$&#123;1==1 &#125;&quot;&gt;满足条件时，中间的内容才会显示出来&lt;/c:if&gt;\n\n通过是结合 EL 表达式一起使用，EL 从域中取数据，使用JSTL进行判断或者遍历\n\n123&lt;%request.setAttribute(&quot;money&quot;, 3);%&gt;&lt;c:if test=&quot;$&#123;money &gt; 50&#125;&quot;&gt;金额大于：50&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;money &lt; 50&#125;&quot;&gt;金额小于：50&lt;/c:if&gt;\n做一个 if 标签的使用，需求：用户登录成功时， 进入首页中，显示用户名。\n\n1.登录成功时，把用户写到 session 域当中。\n\n123456789//有值if(u != null)&#123;    response.getWriter().write(&quot;登录成功&quot;);    //把用户存在session当中    HttpSession session = request.getSeesion();    session.setAttribute(&quot;user&quot;,u);    //跳转到登录    response.setHeader(&quot;refresh&quot;,&quot;3;url=/项目地址/index.jsp&quot;);&#125;\n\n2.在首页当中进行判断，从 session 域当中取数据。\n3.通过EL结合JSTL进行判断\n\n123456789&lt;c:if test=&quot;$&#123;empty user&#125;&quot;&gt;&lt;a href=&quot;Login.jsp&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;regist.jsp&quot;&gt;免费注册&lt;/a&gt;&lt;/c:if&gt;    &lt;c:if test=&quot;$&#123;！empty user&#125;&quot;&gt;欢迎：$&#123;user.username&#125;&lt;a href=&quot;#&quot;&gt;退出&lt;/a&gt;&lt;/c:if&gt;\nforeach 标签\n\n普通循环\n\n1234&lt;!-- 从域当中取数据 自动把数据存储 pageScope --&gt;&lt;c:forEach begin=&quot;0&quot; end=&quot;5&quot; var=&quot;i&quot;&gt;\t$&#123;i&#125;&lt;br/&gt;&lt;/c:forEach&gt;\n\n增加 for 循环\n\n遍历字符串集合\n1234567891011&lt;%    list&lt;String&gt; strList = new ArrayList&lt;String&gt;();\tstrList.add(&quot;aaa&quot;);\tstrList.add(&quot;aaa&quot;);\tstrList.add(&quot;aaa&quot;); %&gt;   &lt;!--会自动把取出来的值放入到pageScope域当中--&gt;&lt;c:forEach items=&quot;$&#123;strList&#125;&quot; var=&quot;str&quot;&gt;    $&#123;str&#125;&lt;/c:forEach&gt;     \n遍历对象集合\n1234567891011121314&lt;%    list&lt;User&gt; userList = new ArrayList&lt;User&gt;();\tUser u1 = new User();\tu1.setUsername(&quot;李四&quot;);\t\tUser u2 = new User();\tu2.setUsername(&quot;王五&quot;);\tuserList.add(u1);\tuserList.add(u2);\tsession.setAttribute(&quot;userList&quot;,userList); %&gt;&lt;c:forEach items=&quot;$&#123;userList&#125;&quot; var=&quot;user&quot;&gt;  $&#123;user.username&#125;&lt;/c:forEach&gt;\n遍历 map\n12345678910&lt;%\tMap&lt;String,String&gt; strMap = new HashMap&lt;String,String&gt;();\tstrMap.put(&quot;name&quot;,&quot;李四&quot;);\tstrMap.put(&quot;age&quot;,&quot;28&quot;);\tstrMap.put(&quot;addr&quot;,&quot;天津&quot;);\tsession.setAttribute(&quot;me&quot;,strMap);%&gt;&lt;:forEach items=&quot;$&#123;me&#125;&quot; var=&quot;entry&quot;&gt;\t$&#123;entry.key&#125;:$&#123;entry.value&#125;&lt;/:forEach&gt;\n\n像是 jstl 的标签库还有很多，这里只介绍了两个标签。\n","plink":"https://pinkpeachabc.cn/EL与JSTL/"},{"title":"JSP的基本语法","date":"2020-03-04T06:42:17.000Z","date_formatted":{"ll":"2020年3月4日","L":"2020/03/04","MM-DD":"03-04"},"updated":"2020-08-16T13:30:21.449Z","content":"JSP 简介\n\n前两章写的响应和 session，这次我来说一下 jsp 😀\n\n什么是 JSP\nJSP 全名为 Java Server Pages，中文名叫 java 服务器页面。在传统的网页HTML文件(.htm,.html)中插入 Java 程序段和 JSP 标记，缀名为(*.jsp)。\n为什么要有 JSP\n直接使用 Html 文件是没有办法输出 Java 当中的信息，使用 servlet 来去输出一个网页非常的麻烦。于是就出现了jsp，又能写 html，又能写 Java 代码\nJSP 的组成部分\n静态数据，如 HTML\nJSP 脚本元素和变量\nJSP 指令，如 include 指令\nJSP 标签动作\n用户自定义标签\nJSP脚本元素和变量\n在 JSP 当中写 Java 代码\n&lt;%java代码%&gt;内部的 java 代码翻译到 service 方法的内部\n&lt;%=java变量或表达式&gt;会被翻译成 service 方法内部 out.print()\n&lt;%!java代码%&gt;会被翻译成 servlet 的成员的内容\nJSP 注释\nHTML 注释：&lt;!--注释内容--&gt;\n可见范围 jsp 源码、翻译后的 servlet、页面\nJava 注释\n//单行注释  /*多行注释*/\n可见范围 jsp 源码 翻译后的 servlet,页面中看不到\nJsp 注释\n&lt;%--注释内容--%&gt;\n可见范围 jsp 源码可见\nJSP 指令\n什么是指令\n\nJSP 指令用于设置整个 JSP 页面的相关信息，以及用于 JSP 页面与其它容器之间的通信。\n\n有哪些指令\n\npage 指令\tinclude 指令\ttaglib 指令\n\npage 指令\n1&lt;%@page &quot;指令&quot; %&gt;\n用于设定整个 JSP 页面的属性和相关功能，多个属性之间使用空格隔开。page 指令共有 11 个属性分别是：\n​\tcontentType\n​\tcontentType 属性指定 JSP 页面的 MIME 和编码格式\n​\tbuffer\n​\t用来设置输出流缓冲区,缓冲区的作用就是为了提高 IO 性能,也就是说减少 write 的次数\n​\tlanguage 属性\n​\t指定页面中使用的脚本语言种类,目前只支持 java\n​\tisErrorPage\n​\t允许指定的 JSP 页面为错误处理页面\n​\tautoFlush\n​\t用来指定当输出流缓冲区满了的时候，是否自动刷新缓冲区\n​\terrorPage\n​\t如果当前页面发生异常,网页会重定向到 errorPage 所指定的页面进行处理\n​\textends\n​\t用于指定该 JSP 生成的 servlet 继承自哪个父类,必须指定包名加类名\n​\tsession\n​\t指定当前页面是否能获得当前用户的 session 对象,缺省是 true\n​\t如果指定为 false,那么在该页面中无法使用 session，使用的话会提示500错误\n​\timport\n​\t在 JSP 中引入 Java 的包和类，多个包之间以逗号隔开\n​\tinfo\n​\t用来设置该 jsp 文件的介绍信息\n​\tpageEncoding\n​\tpageEncoding 属性用来指定 JSP 文件的编码格式\n​\tisELIgnored\n​\t用来标示是否支持 EL 表达式\n​\tisThreadSafe\n​\t缺省值为 true\n​\t指定该 JSP 文件是否支持多线程访问\ninclude指令\n表示在JSP编译时插入一个包含文件或者代码的文件，include 指令所包含的文件名不能是一个变量 url,只能是静态的文件名。\n\n静态包含\n\n12&lt;%@include file=&quot;header.jsp&quot;%&gt;&lt;%@include file=&quot;footer.jsp&quot;%&gt;\n将两个 jsp 页面接着到一起， 然后再翻译成 servlet\ntaglib指令\n声明 JSP 文件使用了标签库\n\n有哪些标签库\n\nJSP 标准标签库，第三方标签库，自定义标签库\nJSP 标签动作\n页面包含\n1&lt;jsp:include page=&quot;被包含的页面&quot;&gt;&lt;/jsp:include&gt;\n\n动态包含\n\n各自翻译自己的页面，然后再引入\n请求转发\n1&lt;jsp:forward page=&quot;要转发的资源&quot;&gt;&lt;/jsp:forward&gt;\nJSP 隐式对象\nout\n123456//out的类型：JspWriter//out作用就是想客户端输出内容 out.write()//out缓冲区默认8kb//可以设置成0 代表关闭out缓冲区内容直接写到respons缓冲区//out写的内容写到out缓冲区当中//最后再把out缓冲区当中的内容合并到response缓冲区当中\nrequest\n得到用户请求信息对象\nresponse\n服务器向客户端的响应对象\nconfig\n服务器配置，可以取得初始化参数\nsession\n用来保存用户会话的信息\napplication\n所有用户的共享信息，就是 servletContext\npage\n指当前页面转换后的 Servlet 类的实例\npageContext\njsp 页面的上下文对象\n\n是一个域对象\n\n123setAttribute(String name,Object obj)getAttribute(String name)removeAttrbute(String name)\n\n可以向指定的其他域中存取数据\n\n12setAttribute(String name,Object obj,int scope)setAttribute(“name”,&quot;lk&quot;,PageContext.REQUEST_SCOPE);\n12getAttribute(String name,int scope)getAttribute(&quot;lk&quot;,PageContext.REQUEST_SCOPE)\n1removeAttrbute(String name,int scope)\n12345findAttribute(String name)//自动到所有的域当中找数据//从小到大的范围搜索数据//依次从 pageContext 域，request 域，session 域，application 域中获取属性//在某个域中获取后将不在向后寻找\n\n可以获得其他 8 大隐式对象\n\n12pageContext.getRequest()pageContext.getSession()\nexception\n表示 JSP 页面所发生的异常，在错误页中才起作用\n只有是错误页面的时候，才会有该对象\n","plink":"https://pinkpeachabc.cn/JSP的基本语法/"},{"title":"cookie与Session","date":"2020-02-27T12:33:57.000Z","date_formatted":{"ll":"2020年2月27日","L":"2020/02/27","MM-DD":"02-27"},"updated":"2020-08-16T13:30:25.537Z","content":"会话概述\n\n什么是会话:从打开浏览器,到访问网页,到最终关闭浏览器,整个过程就是一次会话。\n\n会话的特点\n包含多个请求,一次完整的会话针对一个用户。\n会话管理技术\n\n第一种: cookie 技术,客户端技术\n第二种: session 技术,服务端技术\n\n购物车案列\n\n买完商品后,加入购入车,买的商品存到什么对象比较合适?\n\n\n\n使用 request 域对象保存商品信息\n结论:使用 request 保存商品信息不可以,因为每次发送请求,都会产生一个新的请求对象\n\n\n使用 ServletContext 域对象保存商品信息\n结论:使用 ServletContext对象保存商品信息,可以,但是不合理\n\n\n所以在开发中,保存会话过程中产生的数据,采用会话管理技术,也就是使用 cookie 和  session 技术来保存会话过程产生的数据。\nCookie\n\n服务器怎样把 cookie 发给客户端\n\n创建 Cookie\n1Cookie cookie = new Cookie(String cookieName,String cookieValue);\n向客户端发送 cookie\n1response.addCookie(cookie);\n访问\n\n第一次访问时,请求头当中没有 cookie\n第一次访问时, 响应当中会看到 set-cookie\n再一次访问时,请求头当中就能够看到 cookie 信息\n\n访问服务器的任何资源，一般情况下都会把 cookie 带去过。\nCookie 默认存储时间\n\n默认 cookie 的是会话级别\n\n打开浏览器，关闭浏览器为一次会话，如果不设置持久化时间，cookie 会存储在浏览器的内存中，浏览器关闭 cookie 信息销毁。\n设置 Cookie 在客户端的存储时间\n1cookie.setMaxAge(int seconds);\n设置的时间为秒，如果设置持久化时间，cookie 信息会被持久化到浏览器的磁盘文件里，过期会自动删除。\nCookie 的携带路径\n\n访问某一个资源时，要不要带 cookie 信息。如果每一外资源都携带，会影响传输速度 。如果不设置携带路径，默认情况下会在访问创建 cookie 的 web 资源相同的路径都携带 cookie 信息。\n\n在 myxq/CookieServlet 下创建的 cookie\n在 myxq/下的index.jsp 访问时会携带 cookie\n不是在 myxq 下，不会携带 cookie\n设置 Cookie 携带路径\n1cookie.setPath(String path);\n12cookie.setPath(&quot;/CookiePro/cookieServlet&quot;);//只有访问 cookieServlet 才携带 cookie 信息\n12cookie.setPath(&quot;/CookiePro&quot;);//访问指定的工程时，都会携带 cookie 信息\n12cookie.setPath(&quot;/&quot;);//访问服务器下部署的所有工程时都会携带 cookie 信息\n删除 Cookie\n\n使用同名同路径的持久化时间为0的cookie进行覆盖即可\n\n1cookie.setMaxAge(0);\n服务器如何获取客户端携带的 Cookie\n\n通过 Request 对象的 getCookies() 方法,获取的是所有的 cookie,要进行遍历，找出自己名称的那一个。\n\n12345678910111213//1.获取所有的cookie的对象Cookie[] cookies = request.getCookies();//2.获取的结果不为空if(cookies != null)&#123;    //3.遍历所有的cookie    for(Cookie cookie:cookies)        //遍历出每一小时，取出对应的名称        String name = cookie.getName();    \t//判断名称是否为自己储存的哪一个    \tif(name.equals(&quot;pinkpeach&quot;))&#123;            System.out.println(cookie.getValue());        &#125;&#125;\nSession对象\n什么是 session\nsession 是一种会话管理技术, session 用来保存会话过程中的数据,保存的数据存储到服务器端。\nsession 原理:基于 cookie 实现的,更确切的说是基于会话级别的 cookie 实现的。\nHttpSession API\n\nsession 常用方法\n\n得到 session 的id( JESSIONID对应的值): getId();\n设置 session 的生命时长: setMaxInactiveInterval(int interval);\n销毁 session: invalidate();\n得到 sessIon: HttpSession session = request.getsession();\nsession 域对象\n\n作用范围一次完整的会话(包含多个请求)\n\n存值: setAttribute(String key, Object obj);\n取值: Object obj= getAttribute(String key);\n移除: removeAttribute(String key);\n总结域对象: request 域对象  session 域对象 servletContext 域对象,作用范围以次变大\nSession超时管理\n\nsession对象是由生命时长,它的默认存活时间是30分钟。\n\n具体配置找 tomcat 软件的 conf 下的web.xml文件\n123&lt;session-config&gt;&lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;\n立即销毁 session 对象: invalidate();\n","plink":"https://pinkpeachabc.cn/JavaWeb-会话/"},{"title":"JavaWeb请求和响应","date":"2020-02-25T00:59:04.000Z","date_formatted":{"ll":"2020年2月25日","L":"2020/02/25","MM-DD":"02-25"},"updated":"2020-07-18T13:09:00.225Z","content":"request 请求对象、response 响应对象\n \n请求和响应的概述\n什么请求: 在浏览器地址栏输入地址,点击回车请求服务器,这个过程就是一个请求过程。\n什么响应: 服务器根据浏览器发送的请求,返回数据到浏览器在网页上进行显示,这个过程就称之为响应。\n \nHttpServletResponse 对象\nHttpServletResponse 是一个接口,它的父接囗是 ServletResponse ,在开发中通常使用，响应信息分为三部分:响应行、响应头、响应正文(响应体)\n发送状态码的相关方法：\n设置状态码 setStatus(int sc):参数就是状态码\n常见的状态码:200 响应成功 、302 重定向 、484 请求资源找不到 、500 服务器代码出异常\n错误信息方法：\nsendError(int sc):参数状态码\nsetStatus(int sc, String sm):第一个参数表示状态码,第二个参数就状态码的描述。\n \n发送响应消息头相关的方法\n\n响应消息头的数据格式:key- value的形式,有的是一个key,一个 value,有的是一个key,多个 value。\n\n\n\n设置响应消息头:\n一个 key ,对应一个  value\nsetHeader(String key, String value);\n比如:\nsetHeader(&quot;aa&quot;,&quot;A&quot;);\n如果:\nsetHeader(&quot;aa&quot;,&quot;AA&quot;);\nsetHeader(&quot;aa&quot;,&quot;BB&quot;);\n最终的结果: aa 这个头对应的值就是 BB\n一个key,对应多个 value\naddHeader(String key, String value);\n比如:\naddHeader(&quot;aa&quot;,&quot;AA&quot;);\naddHeader(&quot;aa&quot;,&quot;BB&quot;);\n最终的结果: aa 这个头对应的值 AA 和 BB\n\n\n设置响应数据的长度:\nsetContentLength(int src) 方法\n\n\n设置处理乱码的方法：\nsetCharacterEncoding(String a);参数就是一个码表格式,比如:“utf-8”\nsetContentType(String a);参数代表响应数据的类型和码表格式,比如:“text/htm1; harset=utf-8”\n1response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n\n\n \n发送响应体相关的方法\n第一个方法: getOutputStream(),通过 response 向浏览器返回图片、视频等二进制数据的文件,当然也可以向浏览器、返回文本数据。\n123ServletOutputStream out = response.getOutputStream();String value = &quot;test&quot;;out.write(value.getBytes());\n第二个方法: getWriter(),通常 response 向浏览器返回文本数据,不能向浏览器返回图片、视频等二进制文件。\n123///字符流向浏览器输出数据PrintWriter out = response.getWriter();out.print(&quot;hello world&quot;);\n \n解决中文输出的乱码问题\n第一种方式:\n12response.setCharacterEncoding(&quot;utf-8&quot;);response.setHeader(&quot;Content-Type&quot;,&quot;text/html; charset=utf-8);\n第二种方式:\n1response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n \n实现网页的定时跳转并刷新\n定时跳转:从一个注册页面跳转到登录页面,输入之前注册的用户名和密码。\n12//1.定时跳转:需要用到 Refresh响应头sponse.setHeader(&quot;Refresh&quot;,&quot;5;URL=/chapter04/login.html&quot;);\n定时刷新:在当前页面的地址不发生变化,但是当前页面自己定时刷新,页面数据会发生变化。\n12response.setHeader(&quot;Refresh&quot;,&quot;5&quot;);response.getwriter().print (new Date());\n \n实现重定向\n \n实现重定向的相关方法：\n第一种方式：302 和 Location 配合使用，实现重定向。\n12response.setStatus(302);response.setHeader(&quot;Location&quot;,&quot;项目地址/index.html&quot;);\n第二种方式：sendRedirect(“项目地址/index.html”);\n重定向通过登录案例来完成：\n需求分析:\n在登录页面输入用户名和密码,在 LoginServlet 里面,判断用户名和密码是否正确。如果输入错误,会重新定向到登录界面,如果正确,跳转到欢迎页面。获取登录页面提交的用户名和密码: request. getParameter() 方法。\n重定向的特点:\n\n浏览器地址栏发生变化\n发送了两次请求。都是由浏览器发送的请求\n\n重定向的路径:\n\n由于是浏览器发送得到请求,所以路径必须要带项目名称。\n\n \nHttpServletRequest请求对象\nHttpServletRequest 它是一个按口,它的父接囗 ServletRequest,在开发中,常用的是带协议的请求对象。请求消息:请求行,请求头,请求参数\n \n获取请求行消息的相关方法:\n获取请求提交的方式: getMethod();\n12String method = request.getMethod();System.out.println(&quot;请求方式：&quot;+ method);\n获取请求的协议: getProtocol();\n12String protocol = request.getProtocol();System.out.println(&quot;请求的协议&quot;+ protocol);\n获取项目名称: getContextPath();\n12String contextPath = request.getContextPath();System.out.println(&quot;项目路径：&quot;+contextPath);\n获取 servlet 路径: getServletPath();\n12String servletPath = request.getServletPath();System.out.println(&quot;servlet路径&quot;+servletPath);\n获取请求路径: getRequsetURI();  getRequestURL();\n123String uri = request.getRequestURI();StringBuffer url = request.getRequestURL();System.out.println(&quot;uri对应的值：&quot; + uri + &quot;url对应的值&quot; + url);\nurl 对应的值:/项目名称/servlet路径\nurl 对应的值:http://localhost:8080/url\t\n \n获取请求消息头相关的方法\n根据消息头,获取值\n1String value = request.getHeader(消息头的名称);\n获取所有的消息头\n1Enumeration&lt;String&gt; headerNames = request.getHeaderNames();\n \n获取请求参数相关的方法\n根据 name 属性值,获取用户输入的值\n1String value = getParameter(name属性对应的值);\n根据 name 属性值,获取用户选择的值\n1String[] vaules = getParametervalues(name属性对应的值);\n没有参数,获取所有值\n1Map&lt;String, String[]&gt; map = getparameterMap();\n \n解决请求参数的中文乱码问题:\n中文乱码处理分两种情况\n第一种情况:处理 get 方式提交的中文乱码\n使用的 String 的构造方法解决的中文乱码: new String(字节数组,编码格式);\n1String newvalue = new String(value getBytes(&quot;IS08859-1&quot;),&quot;utf-8&quot;);\n第二种情况:处理 post 请求的中文乱码\npost提交,会把参数首先提交到 request 对象的缓冲 区中,缓冲区默认编码是 ISO8859-1,不支持中文\n处理方法:把 request 缓冲区的编码给设置成支持中文的码表格式\n1request.setCharacterEncoding(&quot;utf-8&quot;);\n \n通过 Requset对象传递数据\n什么域对象:在一定的范围内,可以存值和取值。request 域对象:在一次请求中,可以存值和取值。\n存值: setAttribute(String key, Object obj);\n取值: Object obj =  getAttribyte(String key);\n移除: removeAttribute(String key);\n \nRequestDispatcher 接口\n在开发中访问到一个 web 资源后,需要服务器跳转到另一个资源去处理请求,可以通过 sendRedirect 重定向\n方法来实现,也可以 RequestDispatcher 转发对象的 forward 方法来实现\n1RequestDispatcher forwardobj = request. getRequestDispatcher(&quot;另一个资源的路径&quot;);\n常用方法:\n实现请求转发: forwardobj.forward(request,response);\n实现请求包含: forwardobj.include(request,response);\n请求转发:\n特点:发送了一次请求,响应一次,和 request 域对象配合使用,可以实现值得传递。\n转发路径:转发动作是在服务器内部实现的,所以转发路径不要携带项目名称。\n请求重定向:\n特点:发送了两次请求,响应了两次,不能和 request 域对象配合使用。\n重定向路径:重定向动作在浏览器端执行的,所以路径需要携带项目名称。\n请求包含:\n特点:发送一次请求,请求包含是由服务器完成。\n请求包含路径:在服务器内部完成的,路径不需要携带项目名称。\n\n","plink":"https://pinkpeachabc.cn/响应头/"},{"title":"Mac终端配置代理","date":"2020-01-31T11:45:51.000Z","date_formatted":{"ll":"2020年1月31日","L":"2020/01/31","MM-DD":"01-31"},"updated":"2020-06-06T13:01:13.585Z","content":"在使用终端时候难免会浏览和下载墙外的资料，这时候就要用到代理。下面我来为大家介绍一下在Mac环境下终端的代理方法。\n\n准备\n在操作以下步骤之前，需要配置好 Shadowsocks。\n方法一：\n在终端中依次执行以下命令的前两个或者直接执行最后一个即可\n123456# 配置http访问的export http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080# 配置https访问的export https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080# 配置http和https访问export all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080\n\n这里的端口具体要看使用的工具，具体如下。\n\n\n这里就要输入1086端口。\n这个办法的好处是简单直接，并且影响面很小（只对当前终端有效）。\n输入curl cip.cc来查看终端是否成功代理。\n\n方法二：\n把代理服务器地址写入 shell 配置文件 .bash_profile 或者 .zshrc。\n终端执行 vim ~/.bash_profile 或者 vim ~/.zshrc 配置全局环境变量。\n直接在 . bash_profile 或者 .zshrc 添加下面内容\n123456789101112131415161718192021# 终端设置代理# -------------------------------# polipo proxy on&#x2F;off# ------------------------------function proxy_on() &#123;    # 配置http访问的    export http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080    # 配置https访问的    export https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080    # 配置http和https访问    export all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080    echo &#39;********   开启当前终端代理   ********&#39;&#125;function proxy_off() &#123;    # 移除代理    unset http_proxy    unset https_proxy    unset all_proxy    echo &#39;********   关闭当前终端代理   ********&#39;&#125;\n编辑完之后执行 source ~/.bash_profile 或者 source ~/.zshrc ，编辑的哪个执行哪个就行。\n使用时在终端执行\n\n启动：proxy_on\n关闭：proxy_off\n\n这个办法的好处是随时用随时开关，方便快捷，并且影响面也同样很小（在执行的终端设置代理，只对执行的终端有效，不影响其他终端）。\n方法三：（配置全局代理 慎用）\na. 设置代理\n12git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;\nb. 查看信息 git 配置信息\n1git config --global -l \nc. git 移除全局配置代理\n12git config --global --unset http.proxygit config --global --unset https.proxy\n\n如果 git 配置了全局的代理会影响到 sourcetree 或者其他命令终端的 git 命令，请小心使用！！！\n\n\n参考文章\nMac终端配置代理\n","thumbnail":"https://tva1.sinaimg.cn/large/006tNbRwly1gbfziydz2jj30jd0d9tbs.jpg","plink":"https://pinkpeachabc.cn/Mac-terminal/"},{"title":"你活成你想要的样子了吗？","date":"2020-01-17T02:56:06.000Z","date_formatted":{"ll":"2020年1月17日","L":"2020/01/17","MM-DD":"01-17"},"updated":"2020-05-23T13:40:32.898Z","content":"\n20年的时光悄然而逝，现在我也清楚了高中时在作文纸上写的光阴似箭，日月如梭。回头想想，我现在的样子是我曾经想要成为的样子吗。\n\n\n\n日程\n\n123456789- 放假的第10天\t- 小年\t- 距离除夕7天- 假期倒计时30天\t- 认真学习\t- 快乐生活\t- 完成一个项目\t- 勤更新博客\n追赶\n没能活成别人期待的模样，\n也没活成自己想要的样子。\n不知觉的自己看看流失的时间回头看看已经二十一二岁。\n慢慢独立，对自己的行为、生活负责。\n回想起高中坐在教室中的自己奋笔疾书的样子，现在也许会一笑而过。\n高考失利对我来说可以说是在情理之中，说实话现在想想那时候还挺难受的。\n我还是来到了现在的学校报到了，我没有选择复读。一是条件麻烦、二是压力太大，又害怕第二年承受不住亲戚朋友的“关怀”，现在想想也许是后者吧。\n第一年的时光，慢慢过去了。我也就这件事慢慢释然了，有时候我觉得这样也好做点自己喜欢的事，认真学习，好好的生活。争取能和以前不同。\n我还是喜欢不同和新鲜，像是很久不见再相逢之后的那种新鲜，但在交流后却还能保持那种熟悉的味道。\n16年高中，我记得当时在一起看过电影《谁的青春不迷茫》，在枯燥的校园也算是一个开心事。\n当时想想现在的导演天天拿这些IP做宣传，拍电影真没新意。我也不是活的好好不如好好的睡一觉想想晚饭吃什么。\n渐渐的我也出现了迷茫期，高三我拿着那时候的成绩单，看看分数在看看自己，也不过轻叹口气罢了。\n我也开始追赶的大家的脚步，集腋成裘，积沙成塔。这两个也是当时的语文老师教给我的。\n一粒砂土，或许太渺小，但堆积起来，却是大山的脊梁。\n我虽然没成为脊梁，但起码不会让自己为了后悔而抱怨了。因为我知道我现在是起点，我还有更好的重点等着我。\n高中的我感觉时间过的真的很慢，你打个瞌睡、偷个懒也不会影响当时的自己。现在想想自己也太可笑了，眼看就要大三了，专业课是否学的扎实，是否能胜任一份好的工作。\n在这长河中有几只船只，两只：一只为名，一只为利。越长大越知道钱的作用。\n我想要快乐。我想要快乐。我想要快乐。细想之下我已经很久没有真诚地快乐过，始终背着不知何处来的重担行走在冷夜里，担子里有焦虑、自我厌弃、负罪感、虚无感……崩溃和哭泣。\n亲戚吃饭，席间话话题落到我身上，嘘寒问暖，我很开心，很也讨厌。我享受亲情的温暖也害怕自己的不足。我笑，心里也觉得好笑。\n我也会和以前做个记号，为以前的生活Delete 有时候有的生活是不需要保存的，因为期待总在明天。\n奔跑🏃\n如今，是我缓口气的日子。然而我又喜欢又害怕这种生活，缓的气的多了也会得病。\n环境造就人没错，我相信真正影响自己的还是自己。\n自己不相信自己终究还是不自信。\n改变需要时间也需要勇气，我要改变的不只是外观，还有内在。\n我讨厌追赶的日子，也许你当年并没有掉队。你不过是没有追赶的方向，你嫉妒和你一起的朋友同学考上的更好的学校。\n现在我喜欢上了将自己写在文字里，即使没有文笔，我也特别喜欢这种感觉。\n表述只是一种方式，希望你能找到你的way。\n愿你再次见我的时候不是在追赶，而是在奔跑。\n\n\n最后我将这篇文章由Text2Image转化成的图片，贴附文章底部。\n\n\n","thumbnail":"https://tva1.sinaimg.cn/large/006tNbRwly1gazpf9004rj30hz0jcwld.jpg","plink":"https://pinkpeachabc.cn/2020/"},{"title":"在Mac上为图片添加阴影，让截图更好看","date":"2020-01-15T09:19:59.000Z","date_formatted":{"ll":"2020年1月15日","L":"2020/01/15","MM-DD":"01-15"},"updated":"2020-05-23T13:45:04.014Z","content":"对于经常写文章稿件类的工作者来说，排版决定给读者的第一印象。虽然Mac本身就自带为图片加阴影的功能，但却仅仅于此。下面为大家带来一款方便好用的截图工具**——Xnip**\n\n首先让我来介绍Mac截图的使用技巧\n\nMac 截图阴影 &amp; 截图小技巧\n大家都知道，macOS 自带的 自由截图键 是 Command + Shift + 4，全屏截图键 是 Command + Shift + 3。\n添加截图阴影：当你希望给某个窗口添加阴影时，只需要再按下空格键。也就是组合键 Command + Shift + 4 + Spacebar 就可以截下这个窗口，保存时会自动添加阴影。\n截图到剪贴板：在进行上面这些组合键的同时，多按一个 Control 键，截图就不会保存到桌面，而是自动进入剪切板，方便粘贴到其他地方。\n调整截图范围：先按下 Command + Shift + 4 后，拖动鼠标截图，此时——\n\n\n按住鼠标，同时按住 Option，可以让截图范围以中心对称。\n\n\n按住鼠标，同时按住 Shift，可以固定截图范围的宽高。\n\n\n按住鼠标，同时按住 Spacebar，可以整块移动截图范围。\n\n\nOption 和 Shift 可以组合使用。\n\n\nXnip - Screenshot &amp; Annotation\n\n外观美丽的不像实力派，我本是一直使用Mac自带的截图工具。每当想要长截图或者做一些更高级的注释的时候自带的截图工具就不在满足我的要求。于是这款软件片成为了我最爱的截图工具。\n\n滚动截图\n\n这个功能是我最喜欢的功能不仅可以完美的把整个网页截图下来，并且可以指定我截取的范围。\n截取多个窗口\n\n这项功能是对我来说是比较有特色的，当运用对比的时候这个功能可以更好的实现。同时添加了Mac自带的截取窗口阴影，这样也有利于排版。\n标注\n\nXnip 拥有齐全的标注功能，你可以对截取的图片进行标注，在标注的同时还能重新调整截图大小。\n参考文章\n在 Windows 上为图片添加阴影，让截图更好看\nXnip - Mac 上方便好用的截图工具，支持滚动截图\n","thumbnail":"https://tva1.sinaimg.cn/large/006tNbRwly1gaxddxp6myj31bf0s1wph.jpg","plink":"https://pinkpeachabc.cn/截图工具/"},{"title":"域名解析配置教程","date":"2020-01-09T05:58:38.000Z","date_formatted":{"ll":"2020年1月9日","L":"2020/01/09","MM-DD":"01-09"},"updated":"2020-05-20T01:13:27.147Z","content":"域名\n关于域名简单的来说就是网址。我们购买的域名一般都是一级域名，一级域名又叫顶级域名，域名大概分三种分别是。\n\n\n一级域名：我购买的pinkpeachabc.cn就是一级域名，一串字符串中间一个点隔开，并且一级域名比二级域名更容易收录。\n\n\n二级域名：二级域名相当于一级域名前面的前缀，只要是xxx.xxxx.xxx此类都属于二级域名，.的前面可以写任意内容只需要在域名解析里面添加就可以了。\n\n\n三级域名：二级域名的子域名，特征是包含三个“.”。例如xxx.xxx.baidu.com ，xxx上可以填写任意内容，都属于三级域名。\n\n\n\n由于国内和国外对域名级别的解读不同就不在赘述区别，国内很多资料认为，顶级域和一级域是分开的，也就是说顶级域左侧的域名是一级域。所以 www.baidu.com 解读域名级别就是：顶级域 com，一级域 baidu，二级域 www。\n\n域名类型\n\n\n这里我以腾讯云云解析为例，介绍我们解析中最常用的几个。一般的情况下选择快速添加解析，只需要把服务器ip填入就可以直接解析。\n\n\nwww：解析后可用 www.xxxx.xxx 访问。\n\n\n@：是指前面不带任何主机名的，以百度为例，就是 baidu.com。\n\n\n*：此为泛解析，在域名前添加任何子域名，均可访问到所指向的WEB地址。\n\n\nA：用于记录用来指定主机名对应的ip地址记录。\n\n\nCNAME：CNAME类型解析设置的方法和A记录类型基本是一样的，其中将记录类型修改为“CNAME”，并且记录值填写服务器主机地址即可。\n\n\n\n更全面的用法和类型，可以直接登录你所购买域名地方具体查看，若怕麻烦可以直接选择快速解析直接填入服务器地址即可。\n","thumbnail":"https://tva1.sinaimg.cn/large/006tNbRwly1gaq8bqxov2j31af0sq12m.jpg","plink":"https://pinkpeachabc.cn/yu-ming-jie-xi/"},{"title":"Blog搭建流程","date":"2020-01-01T15:11:10.000Z","date_formatted":{"ll":"2020年1月1日","L":"2020/01/01","MM-DD":"01-01"},"updated":"2020-05-23T13:44:22.364Z","content":"\n本文转自: Blog搭建流程(Mac系统完结帖)\n原文地址: http://www.ivan-zcy.top/2018/09/30/Blog\n\n\nStep1 安装Node.js\n可通过以下两种方式在 Mac OS 上安装 node.js：\n方式一： 在官方下载网站下载 pkg 安装包，直接点击安装即可\n方式二： 使用 brew 命令来安装：\n1brew install node\nStep2 安装Git\n首先查看电脑是否安装Git，终端输入：\n1git\n安装过则会输出下表，然后跳过该步\n12345678910111213141516171819202122232425262728293031323334353637383940414243WMBdeMacBook-Pro:~ WENBO$ gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c name&#x3D;value]           [--exec-path[&#x3D;&lt;path&gt;]] [--html-path] [--man-path] [--info-path]           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]           [--git-dir&#x3D;&lt;path&gt;] [--work-tree&#x3D;&lt;path&gt;] [--namespace&#x3D;&lt;name&gt;]           &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial)   clone      Clone a repository into a new directory   init       Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday)   add        Add file contents to the index   mv         Move or rename a file, a directory, or a symlink   reset      Reset current HEAD to the specified state   rm         Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions)   bisect     Use binary search to find the commit that introduced a bug   grep       Print lines matching a pattern   log        Show commit logs   show       Show various types of objects   status     Show the working tree statusgrow, mark and tweak your common history   branch     List, create, or delete branches   checkout   Switch branches or restore working tree files   commit     Record changes to the repository   diff       Show changes between commits, commit and working tree, etc   merge      Join two or more development histories together   rebase     Reapply commits on top of another base tip   tag        Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows)   fetch      Download objects and refs from another repository   pull       Fetch from and integrate with another repository or a local branch   push       Update remote refs along with associated objects&#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and someconcept guides. See &#39;git help &lt;command&gt;&#39; or &#39;git help &lt;concept&gt;&#39;to read about a specific subcommand or concept.\n如果没有显示上面内容，我们可以通过homebrew安装GIt，若未安装homebrew 则通过终端执行：\n1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n随后执行一下命令进行Git的安装\n1brew install git\nStep3 注册Github账号并新建仓库\n网站链接：Github\n注册完账号后需新建一个仓库。注意！！新建的仓库名字必须是username.github.io。例如我username是ivan-zcy，那么仓库名字必须是ivan-zcy.github.io\nStep4 配置SSH Key（可省略 建议配置）\n这一步能省略 但是配置后更新博客就不用每次都输入用户名密码了\n步骤：\n​ 1 检查主机是否已存在SSH Key\n12cd .sshls -la\n若输出的文件列表中存在id_rsa.pub 或 id_dsa.pub 文件，则直接跳到第三小步\n2 创建SSH Key\n在终端输入如下命令\n1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n按下回车 会让输入文件名，直接回车会创建默认文件名的文件 然后会提示输入两次密码(可为空)\n3 添加SSH Key到Github\n（如果之前在Github中添加过SSH 则跳过该步）\n如果你没有指定文件名（也就是使用默认文件名），那么在.ssh文件夹下会有一个id_rsa.pub文件，打开该文件并复制里面的内容\n登录Github，点击右上角头像右边的三角图标，点击Settings –&gt; SSH and GPG keys –&gt; New SSH key。Title 随便填一个，在Key栏中填入复制的内容，点击Add SSH key，就添加成功了\n4 检验SSH Key是否配置成功\n在终端输入如下命令\n1ssh -T git@github.com\n如果最后出现\n1Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n就说明SSH Key配置成功了\nStep5 安装Hexo\n使用npm命令安装Hexo\n1npm install -g hexo\n接着在任意位置创建一个文件夹，如Blog，cd到该路径下执行\n1hexo init\n该命令会在目标文件夹内建立网站所需的基础文件\n接着安装安装依赖包\n1npm install\n此时本地博客就搭建好了\n执行\n12hexo generatehexo server\n此时可在浏览器中输入http://localhost:4000/进行本地查看（其他人无法访问）\n当然 此时可修改本地博客路径下的_config文件对博客进行全局设置，里边设置项挺多就不一一列举啦！自行百度\nStep6 同步到远程Github仓库\n在本地Blog路径下找到_config.yml，把deploy节点修改为：\n1234deploy:  type: git  repo: git@github.com:username&#x2F;username.github.io.git  branch: master\n（其中 username为你的Github用户名）\n为了能够使Hexo部署到GitHub上，需安装一个插件\n1npm install hexo-deployer-git --save\n然后输入以下命令\n123hexo cleanhexo generatehexo deploy\n这时候就可以在浏览器通过输入username.github.io就可以访问你的博客了\nStep7 配置主题\n前边写过配置主题的博文 抛出一个传送门：\n滴滴，我是传送门\n（主题在github上 知乎上 hexo官网上有很多很多 适合自己就好）\n注意点！！！！\n一些主题的功能需要我们自己预先创建好对应的页面，例如标签tags 关于about等等等等\n此时我们需要在本地Blog路径下\n1 添加关于页面（可选）\n使用：hexo new page &quot;about&quot;新建一个 关于我 页面。\n主题的 _config.yml文件中的 menu中进行匹配\n123456menu:  home: &#x2F;      &#x2F;&#x2F;主页  categories: &#x2F;categories &#x2F;&#x2F;分类  archives: &#x2F;archives   &#x2F;&#x2F;归档  tags: &#x2F;tags   &#x2F;&#x2F;标签  about: &#x2F;about   &#x2F;&#x2F;关于                  （添加此行即可）\n也可在本地博客路径 –&gt; source –&gt; about文件下，通过修改其中的index.md对其页面进行配置\n2 添加标签页面（可选）\n使用： hexo new page tags新建一个 标签 页面。\n主题的 _config.yml文件中的 menu中进行匹配\n123456menu:  home: &#x2F;      &#x2F;&#x2F;主页  categories: &#x2F;categories &#x2F;&#x2F;分类  archives: &#x2F;archives   &#x2F;&#x2F;归档  tags: &#x2F;tags   &#x2F;&#x2F;标签                  （添加此行即可）  about: &#x2F;about   &#x2F;&#x2F;关于\n也可在本地博客路径 –&gt; source –&gt; tags文件下，通过修改其中的index.md对其页面进行配置\n除了上边两个之外还有分类categories，自定义页面等等就不一一列举啦 自行百度吧！\nStep8 发布博文\n接着抛链接：\n滴滴，我也是一个传送门\nStep9 绑定个人域名\n步骤：\n1 购买域名\n建议从阿里云平台啦之类的国内大型平台购买（这一步通常需要身份验证之类的 大概需要几天时间吧也记不清楚了 反正挺麻烦挺磨唧的）\n2 配置DNS地址\n进入阿里云控制台 –&gt; 域名 –&gt; 域名列表 找到自己的域名 点击下图红圈圈的“管理”\n\n3 进行域名解析\n找到管理界面下的域名解析 在其中添加3条记录（username是github的用户名）\n123@          A             192.30.252.153@          A             192.30.252.154www      CNAME         username.github.io.\n4添加CNAME文件\n新建一个名为CNAME的文件(无后缀)，内容为你的域名地址。将该文件放到本地博客的source文件夹里面，并更新到Github\n这时候你的博客就建完啦！\n最后附上主页地址： 戳我\n一起造作吧！！！！\n参考链接：\nhttps://segmentfault.com/a/1190000008040387\nhttps://blog.csdn.net/ganzhilin520/article/details/79047249\nhttps://www.jianshu.com/p/e5f95eb990ad\n","thumbnail":"https://tva1.sinaimg.cn/large/006tNbRwly1gajhygh737j317y0u04qu.jpg","plink":"https://pinkpeachabc.cn/Blog搭建流程/"},{"title":"Android数据储存","date":"2019-12-31T14:40:26.000Z","date_formatted":{"ll":"2019年12月31日","L":"2019/12/31","MM-DD":"12-31"},"updated":"2020-01-31T12:03:25.000Z","content":"大部分应用程序都会涉及数据储存方式，Android程序也不例外。Android中的数据储存方式有五种。分别为文件储存、SharedPreferences、SQLite数据库、ContentProvider以及网络储存。根据程序适配的Android SDK版本不同，申请权限分为两种，分别为静态申请和动态申请权限，这次主要讲怎么申请和遇到过的坑。\n\n文件储存遇到的坑\n\n由于Android版本的更新，和现在的手机几乎不再使用SD卡。导致初学者在用这个方法的时候就会出现问题。\n\n在文件存储中分为内部储存和外部储存，出坑的主要是外部储存。在eclipse中可以正常写入可到了Android stuido中却写入不进去。\n首先，若使用外部存储需要先设置外部存储的读写权限，若是不添加将无法写入。\n静态申请权限\n12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;\n\n此方式只适应于Android SDK6.0以下的版本，当大于这个版本的时候就需要添加动态申请权限了。\n\n动态申请权限\n这时候需要新建PermisionUtils类内容如下，最后在需要的地方调用这个类。\n123456789101112131415161718192021public static class PermisionUtils &#123;        // Storage Permissions        private static final int REQUEST_EXTERNAL_STORAGE = 1;        private static String[] PERMISSIONS_STORAGE = &#123;                Manifest.permission.READ_EXTERNAL_STORAGE,                Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;;        public static void verifyStoragePermissions(Activity activity) &#123;            // Check if we have write permission            int permission = ActivityCompat.checkSelfPermission(activity,                    Manifest.permission.WRITE_EXTERNAL_STORAGE);            if (permission != PackageManager.PERMISSION_GRANTED) &#123;                // We don&#x27;t have permission so prompt the user                ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE,                        REQUEST_EXTERNAL_STORAGE);            &#125;        &#125;    &#125;\n1PermisionUtils.verifyStoragePermissions(this);\n\n这个时候在这个时候在点击写入便会出现以下界面：\n\n\n\n这时候我本以为可以直接读出来我写入的内容了，但我还是太年轻了。我还是读取不出来。这个点困扰我很长时间知道我发现了手机里有一个应用访问授权。一定要把它打开！！！\n\n\n\n最后完美读出\n\n\n","plink":"https://pinkpeachabc.cn/Android数据储存/"},{"title":"hexo速度优化，gulp压缩静态资源","date":"2019-12-31T14:21:12.000Z","date_formatted":{"ll":"2019年12月31日","L":"2019/12/31","MM-DD":"12-31"},"updated":"2020-01-31T12:04:02.000Z","content":"\nhexo生成的的public文件夹里的源文件有很多空白，这些空白占据一定空间。gulp可以高效的压缩这些静态资源，从而提高访问速度。\n\n\n插件安装\n安装gulp工具\n1npm install gulp\n安装gulp模块：\n1234gulp-htmlclean &#x2F;&#x2F; 清理htmlgulp-htmlmin &#x2F;&#x2F; 压缩htmlgulp-minify-css &#x2F;&#x2F; 压缩cssgulp-uglify &#x2F;&#x2F; 混淆js\n安装命令：\n1npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save\n创建任务\n在站点根目录下新建gulpfile.js文件，内容如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142var gulp = require(&#x27;gulp&#x27;);//Plugins模块获取var minifycss = require(&#x27;gulp-minify-css&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;);var htmlmin = require(&#x27;gulp-htmlmin&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);//压缩cssgulp.task(&#x27;minify-css&#x27;, function () &#123;return gulp.src(&#x27;./public/**/*.css&#x27;).pipe(minifycss()).pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//压缩htmlgulp.task(&#x27;minify-html&#x27;, function () &#123;return gulp.src(&#x27;./public/**/*.html&#x27;).pipe(htmlclean()).pipe(htmlmin(&#123;removeComments: true,minifyJS: true,minifyCSS: true,minifyURLs: true,&#125;)).pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩js 不压缩min.jsgulp.task(&#x27;minify-js&#x27;, function () &#123;return gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]).pipe(uglify()).pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//4.0以前的写法 //gulp.task(&#x27;default&#x27;, [  //  &#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task(&#x27;default&#x27;, gulp.parallel(&#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, function() &#123;  // Do something after a, b, and c are finished.&#125;));\n使用\n命令：\n1234hexo clean &#x2F;&#x2F;先清理文件hexo g  &#x2F;&#x2F;编译生成静态文件gulp  &#x2F;&#x2F;gulp插件执行压缩任务hexo s &#x2F;&#x2F;开启服务\n当然，通过一个命令也可以：\n1hexo g &amp;&amp; gulp -d","plink":"https://pinkpeachabc.cn/hexo速度优化，gulp压缩静态资源/"},{"title":"macOS 外接鼠标也丝滑柔顺","date":"2019-12-31T11:58:41.000Z","date_formatted":{"ll":"2019年12月31日","L":"2019/12/31","MM-DD":"12-31"},"updated":"2020-05-23T13:49:19.207Z","content":"开启前\n\n开启后\n\n作为一个长期的Windows用户，在初次体现macOS后，感觉最大的差距就是动画效果。多指操作加上丰富的动画交互能感受到macOS上独特的丝滑感，当然了这归功于它的触控板。但难免有时候难免会用到外界鼠标，或者在外界显示器的时候这时候就发现之前平滑的动画不复存在，反而给你带来顿挫感。相信在看完以上的对比后，你会清晰的看到未开启前那种顿挫感，推荐一款软件，让mac上用鼠标也一样顺滑。\nMos\n\n特性\n\n疯狂平滑你的鼠标滚动效果\n支持分离触控板/鼠标事件, 单独翻转鼠标滚动方向。\n滚动曲线的自定义调整。\n支持区分应用处理, 黑/白名单系统。\n用于监控滚动事件的图形化呈现窗口。\n基于 Swift4 构建。\n\n\nMos可以使鼠标平滑滚动，使在外界鼠标后。实现可以同使用触控板一样带来顺滑的动画。但是在某些特殊场景会有冲突，具体请看图上的介绍，同时这款软件免费。\n\n操作方式\n\n\n只需要打开平滑滚动即可\n\n官网地址：https://mos.caldis.me/\n项目github地址：https://github.com/Caldis/Mos\n","plink":"https://pinkpeachabc.cn/macOS-如何像-Windows-一样使用鼠标/"},{"title":"关于","date":"2019-08-18T05:18:01.000Z","date_formatted":{"ll":"2019年8月18日","L":"2019/08/18","MM-DD":"08-18"},"updated":"2020-10-18T05:21:47.365Z","content":"欢迎大家来到我的博客，本站是基于 Github page 搭建的个人博客。本人坐标天津，目前在上大二。以此博客更新，发布自己的动态和个人的学习心得。\n第一次使用 markdown 来写文稿，一切还是这么生疏，好在还是比较容易上手,以后的内容就由此发往 GitHub，来记录本人在大学期间的个人点滴和学习过程。在这段成长中自己还是多少有些后悔的，火车脱离的正确的轨道，开向了未知站。好在火车没有脱轨或是故障，这样我的生活也不是没有方向，只不过多了未知性，希望这几年过后可以看到更好的一个我。\nAndroid 开发、Illustrator、Photoshop、视频剪辑…有很多大胆的想法，也热衷于钻研与计算机有关的一切。建此站的目的想把自己的生活记录下来，在临毕业时有值得回忆的故事.惊风飘白日，光景西驰流。望在对的时间做对的事，别让时间随风走，回头只剩回忆。\n以上简单的介绍下自己目前的情况，这个博客也算是给自己立一个flag。让自己明白生活的意义，明白这几年并不是在虚度光阴，而是有生活的痕迹并且记录了下来。\n\n如果你喜欢这个博客主题你可以点击这个右下角来访问主题作者的 GitHub,也许里面有你想要东西，本博客还有许多不足之处，若您有宝贵的意见也可以点击联系方式来联系我，祝大家在这里玩的开心😄。\n","plink":"https://pinkpeachabc.cn/about/"},{"title":"友链","date":"2020-05-19T12:07:22.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2021-04-28T02:11:34.837Z","content":"怎么可能有顺序呢，当然是随机的~\n\n    \n        \n        \n            xzMhehe\n            The depth of thinking determines your altitude.\n        \n    \n\n本人链接\n\n    \n        \n        \n            HomePage\n            个人主页\n        \n    \n    \n        \n        \n            web后台评论\n            \n        \n    \n        \n        \n        \n            Pink6Back\n            鹰击长空，好高骛远\n        \n    \n\n失效友链\n\n\n失效友链\n糟糕的先收起来\nkeyboard_arrow_down\n\n\n\n    \n        \n        \n            \n            \n        \n    \n\n\n\n\n\n友链记录册\n那些曾经留过痕迹的友链\nkeyboard_arrow_down\n\n\n    2019-12-01 —— xzMhehe\n\n\n\n.friends{display:flex;flex-wrap:wrap;}.friends .brick{-webkit-transition:all .3s ease;transition:all .3s ease;}.friends .brick{display:flex;margin:10px 10px 0 0;text-decoration:none;font-weight:300;padding:10px;background-color:#fff0;border:solid 1px #659eb929;color:#659eb9;text-align:center;border-radius:4px;overflow:hidden}.friends .brick:hover{background-color:#659eb9;color:#fff;border:solid 1px #659eb9;box-shadow:0 6px 16px 0 rgba(80, 178, 243, 0.35);}.blog-avatar:hover{animation:whirl 0.5s;}\n@keyframes whirl{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}.friends .brick:active{-webkit-transform:scale(0.95);-moz-transform:scale(0.95);-ms-transform:scale(0.95);-o-transform:scale(0.95);transform:scale(0.95);}.friends .brick .blog-avatar{background-color:#fff0;color:#fff;border:solid 1px #dbdbdb;border-radius:50%;width:50px;height:50px;}.friends .brick .container{margin-left:10px;}.friends .brick .container .name{font-size:14px;}.friends .brick .container .motto{font-size:12px;margin-top:5px;-webkit-box-orient:vertical;-webkit-line-clamp:1;}\n@media(max-width:450px){.friends .brick{width:100%;}.friends .brick .container{margin-left:0;width:100%;}.motto{width: 100% !important;}}.motto.long{width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}.mdui-panel-item[open] .mdui-panel-item-arrow{transform:rotate(180deg);}.mdui-panel-item-body {height:auto!important;}\n\n本站模板\n1234名称：Pink&#39;s Blog链接：https:&#x2F;&#x2F;pinkpeachabc.cn&#x2F;图标：https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;pinkpeachabc&#x2F;images&#x2F;Blog-imgs&#x2F;logo.png简介：鹰击长空，志存高远。\n申请说明\n\n不违反国家法律。\n请确保你的站点活着。\n在你的友链上添加本站。\n\n格式模板\n欢迎评论区留链接。\n1234名称：&lt;Name&gt;链接：&lt;Link&gt;图标：&lt;Icon&gt;简介：&lt;Word&gt;\n","plink":"https://pinkpeachabc.cn/links/"}]